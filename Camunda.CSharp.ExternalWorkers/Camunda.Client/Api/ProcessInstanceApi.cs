/* 
 * Camunda BPM REST API
 *
 * OpenApi Spec for Camunda BPM REST API.
 *
 * OpenAPI spec version: 7.13.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using RestSharp;
using Camunda.Client.Client;
using Camunda.Client.Model;

namespace Camunda.Client.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
        public interface IProcessInstanceApi : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Deletes a set of process instances asynchronously (batch) based on a historic process instance query.
        /// </remarks>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">**Unallowed property**: &#x60;processInstanceQuery&#x60; (optional)</param>
        /// <returns>BatchDto</returns>
        BatchDto DeleteAsyncHistoricQueryBased (DeleteProcessInstancesDto body = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Deletes a set of process instances asynchronously (batch) based on a historic process instance query.
        /// </remarks>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">**Unallowed property**: &#x60;processInstanceQuery&#x60; (optional)</param>
        /// <returns>ApiResponse of BatchDto</returns>
        ApiResponse<BatchDto> DeleteAsyncHistoricQueryBasedWithHttpInfo (DeleteProcessInstancesDto body = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Deletes a running process instance by id.
        /// </remarks>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to be deleted.</param>
        /// <param name="skipCustomListeners">If set to true, the custom listeners will be skipped. (optional, default to false)</param>
        /// <param name="skipIoMappings">If set to true, the input/output mappings will be skipped. (optional, default to false)</param>
        /// <param name="skipSubprocesses">If set to true, subprocesses related to deleted processes will be skipped. (optional, default to false)</param>
        /// <param name="failIfNotExists">If set to false, the request will still be successful if the process id is not found. (optional, default to true)</param>
        /// <returns></returns>
        void DeleteProcessInstance (string id, bool? skipCustomListeners = null, bool? skipIoMappings = null, bool? skipSubprocesses = null, bool? failIfNotExists = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Deletes a running process instance by id.
        /// </remarks>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to be deleted.</param>
        /// <param name="skipCustomListeners">If set to true, the custom listeners will be skipped. (optional, default to false)</param>
        /// <param name="skipIoMappings">If set to true, the input/output mappings will be skipped. (optional, default to false)</param>
        /// <param name="skipSubprocesses">If set to true, subprocesses related to deleted processes will be skipped. (optional, default to false)</param>
        /// <param name="failIfNotExists">If set to false, the request will still be successful if the process id is not found. (optional, default to true)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteProcessInstanceWithHttpInfo (string id, bool? skipCustomListeners = null, bool? skipIoMappings = null, bool? skipSubprocesses = null, bool? failIfNotExists = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Deletes a variable of a process instance by id.
        /// </remarks>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to delete the variable from.</param>
        /// <param name="varName">The name of the variable to delete.</param>
        /// <returns></returns>
        void DeleteProcessInstanceVariable (string id, string varName);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Deletes a variable of a process instance by id.
        /// </remarks>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to delete the variable from.</param>
        /// <param name="varName">The name of the variable to delete.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteProcessInstanceVariableWithHttpInfo (string id, string varName);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Deletes multiple process instances asynchronously (batch).
        /// </remarks>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">**Unallowed property**: &#x60;historicProcessInstanceQuery&#x60; (optional)</param>
        /// <returns>BatchDto</returns>
        BatchDto DeleteProcessInstancesAsyncOperation (DeleteProcessInstancesDto body = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Deletes multiple process instances asynchronously (batch).
        /// </remarks>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">**Unallowed property**: &#x60;historicProcessInstanceQuery&#x60; (optional)</param>
        /// <returns>ApiResponse of BatchDto</returns>
        ApiResponse<BatchDto> DeleteProcessInstancesAsyncOperationWithHttpInfo (DeleteProcessInstancesDto body = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Retrieves an Activity Instance (Tree) for a given process instance by id.
        /// </remarks>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance for which the activity instance should be retrieved.</param>
        /// <returns>ActivityInstanceDto</returns>
        ActivityInstanceDto GetActivityInstanceTree (string id);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Retrieves an Activity Instance (Tree) for a given process instance by id.
        /// </remarks>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance for which the activity instance should be retrieved.</param>
        /// <returns>ApiResponse of ActivityInstanceDto</returns>
        ApiResponse<ActivityInstanceDto> GetActivityInstanceTreeWithHttpInfo (string id);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Retrieves a variable of a given process instance by id.
        /// </remarks>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to retrieve the variable for.</param>
        /// <param name="varName">The name of the variable to retrieve.</param>
        /// <param name="deserializeValue">Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine. (optional, default to true)</param>
        /// <returns>VariableValueDto</returns>
        VariableValueDto GetProcessInstanceVariable (string id, string varName, bool? deserializeValue = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Retrieves a variable of a given process instance by id.
        /// </remarks>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to retrieve the variable for.</param>
        /// <param name="varName">The name of the variable to retrieve.</param>
        /// <param name="deserializeValue">Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine. (optional, default to true)</param>
        /// <returns>ApiResponse of VariableValueDto</returns>
        ApiResponse<VariableValueDto> GetProcessInstanceVariableWithHttpInfo (string id, string varName, bool? deserializeValue = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Retrieves the content of a Process Variable by the Process Instance id and the Process Variable name. Applicable for byte array or file Process Variables.
        /// </remarks>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to retrieve the variable for.</param>
        /// <param name="varName">The name of the variable to retrieve.</param>
        /// <returns>byte[]</returns>
        byte[] GetProcessInstanceVariableBinary (string id, string varName);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Retrieves the content of a Process Variable by the Process Instance id and the Process Variable name. Applicable for byte array or file Process Variables.
        /// </remarks>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to retrieve the variable for.</param>
        /// <param name="varName">The name of the variable to retrieve.</param>
        /// <returns>ApiResponse of byte[]</returns>
        ApiResponse<byte[]> GetProcessInstanceVariableBinaryWithHttpInfo (string id, string varName);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Retrieves all variables of a given process instance by id.
        /// </remarks>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to retrieve the variables from.</param>
        /// <param name="deserializeValue">Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine. (optional, default to true)</param>
        /// <returns>Dictionary&lt;string, VariableValueDto&gt;</returns>
        Dictionary<string, VariableValueDto> GetProcessInstanceVariables (string id, bool? deserializeValue = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Retrieves all variables of a given process instance by id.
        /// </remarks>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to retrieve the variables from.</param>
        /// <param name="deserializeValue">Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine. (optional, default to true)</param>
        /// <returns>ApiResponse of Dictionary&lt;string, VariableValueDto&gt;</returns>
        ApiResponse<Dictionary<string, VariableValueDto>> GetProcessInstanceVariablesWithHttpInfo (string id, bool? deserializeValue = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Queries for process instances that fulfill given parameters. Parameters may be static as well as dynamic runtime properties of process instances. The size of the result set can be retrieved by using the Get Instance Count method.
        /// </remarks>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sortBy">Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter. (optional)</param>
        /// <param name="sortOrder">Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter. (optional)</param>
        /// <param name="firstResult">Pagination of results. Specifies the index of the first result to return. (optional)</param>
        /// <param name="maxResults">Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)</param>
        /// <param name="processInstanceIds">Filter by a comma-separated list of process instance ids. (optional)</param>
        /// <param name="businessKey">Filter by process instance business key. (optional)</param>
        /// <param name="businessKeyLike">Filter by process instance business key that the parameter is a substring of. (optional)</param>
        /// <param name="caseInstanceId">Filter by case instance id. (optional)</param>
        /// <param name="processDefinitionId">Filter by the deployment the id belongs to. (optional)</param>
        /// <param name="processDefinitionKey">Filter by the key of the process definition the instances run on. (optional)</param>
        /// <param name="processDefinitionKeyIn">Filter by a comma-separated list of process definition keys. A process instance must have one of the given process definition keys. (optional)</param>
        /// <param name="processDefinitionKeyNotIn">Exclude instances by a comma-separated list of process definition keys. A process instance must not have one of the given process definition keys. (optional)</param>
        /// <param name="deploymentId">Filter by the deployment the id belongs to. (optional)</param>
        /// <param name="superProcessInstance">Restrict query to all process instances that are sub process instances of the given process instance. Takes a process instance id. (optional)</param>
        /// <param name="subProcessInstance">Restrict query to all process instances that have the given process instance as a sub process instance. Takes a process instance id. (optional)</param>
        /// <param name="superCaseInstance">Restrict query to all process instances that are sub process instances of the given case instance. Takes a case instance id. (optional)</param>
        /// <param name="subCaseInstance">Restrict query to all process instances that have the given case instance as a sub case instance. Takes a case instance id. (optional)</param>
        /// <param name="active">Only include active process instances. Value may only be true, as false is the default behavior. (optional, default to false)</param>
        /// <param name="suspended">Only include suspended process instances. Value may only be true, as false is the default behavior. (optional, default to false)</param>
        /// <param name="withIncident">Filter by presence of incidents. Selects only process instances that have an incident. (optional, default to false)</param>
        /// <param name="incidentId">Filter by the incident id. (optional)</param>
        /// <param name="incidentType">Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)</param>
        /// <param name="incidentMessage">Filter by the incident message. Exact match. (optional)</param>
        /// <param name="incidentMessageLike">Filter by the incident message that the parameter is a substring of. (optional)</param>
        /// <param name="tenantIdIn">Filter by a comma-separated list of tenant ids. A process instance must have one of the given tenant ids. (optional)</param>
        /// <param name="withoutTenantId">Only include process instances which belong to no tenant. (optional, default to false)</param>
        /// <param name="processDefinitionWithoutTenantId">Only include process instances which process definition has no tenant id. (optional, default to false)</param>
        /// <param name="activityIdIn">Filter by a comma-separated list of activity ids. A process instance must currently wait in a leaf activity with one of the given activity ids. (optional)</param>
        /// <param name="rootProcessInstances">Restrict the query to all process instances that are top level process instances. (optional, default to false)</param>
        /// <param name="leafProcessInstances">Restrict the query to all process instances that are leaf instances. (i.e. don&#x27;t have any sub instances). (optional, default to false)</param>
        /// <param name="variables">Only include process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)</param>
        /// <param name="variableNamesIgnoreCase">Match all variable names in this query case-insensitively. If set to true variableName and variablename are treated as equal. (optional, default to false)</param>
        /// <param name="variableValuesIgnoreCase">Match all variable values in this query case-insensitively. If set to true variableValue and variablevalue are treated as equal. (optional, default to false)</param>
        /// <returns>List&lt;ProcessInstanceDto&gt;</returns>
        List<ProcessInstanceDto> GetProcessInstances (string sortBy = null, string sortOrder = null, int? firstResult = null, int? maxResults = null, string processInstanceIds = null, string businessKey = null, string businessKeyLike = null, string caseInstanceId = null, string processDefinitionId = null, string processDefinitionKey = null, string processDefinitionKeyIn = null, string processDefinitionKeyNotIn = null, string deploymentId = null, string superProcessInstance = null, string subProcessInstance = null, string superCaseInstance = null, string subCaseInstance = null, bool? active = null, bool? suspended = null, bool? withIncident = null, string incidentId = null, string incidentType = null, string incidentMessage = null, string incidentMessageLike = null, string tenantIdIn = null, bool? withoutTenantId = null, bool? processDefinitionWithoutTenantId = null, string activityIdIn = null, bool? rootProcessInstances = null, bool? leafProcessInstances = null, string variables = null, bool? variableNamesIgnoreCase = null, bool? variableValuesIgnoreCase = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Queries for process instances that fulfill given parameters. Parameters may be static as well as dynamic runtime properties of process instances. The size of the result set can be retrieved by using the Get Instance Count method.
        /// </remarks>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sortBy">Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter. (optional)</param>
        /// <param name="sortOrder">Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter. (optional)</param>
        /// <param name="firstResult">Pagination of results. Specifies the index of the first result to return. (optional)</param>
        /// <param name="maxResults">Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)</param>
        /// <param name="processInstanceIds">Filter by a comma-separated list of process instance ids. (optional)</param>
        /// <param name="businessKey">Filter by process instance business key. (optional)</param>
        /// <param name="businessKeyLike">Filter by process instance business key that the parameter is a substring of. (optional)</param>
        /// <param name="caseInstanceId">Filter by case instance id. (optional)</param>
        /// <param name="processDefinitionId">Filter by the deployment the id belongs to. (optional)</param>
        /// <param name="processDefinitionKey">Filter by the key of the process definition the instances run on. (optional)</param>
        /// <param name="processDefinitionKeyIn">Filter by a comma-separated list of process definition keys. A process instance must have one of the given process definition keys. (optional)</param>
        /// <param name="processDefinitionKeyNotIn">Exclude instances by a comma-separated list of process definition keys. A process instance must not have one of the given process definition keys. (optional)</param>
        /// <param name="deploymentId">Filter by the deployment the id belongs to. (optional)</param>
        /// <param name="superProcessInstance">Restrict query to all process instances that are sub process instances of the given process instance. Takes a process instance id. (optional)</param>
        /// <param name="subProcessInstance">Restrict query to all process instances that have the given process instance as a sub process instance. Takes a process instance id. (optional)</param>
        /// <param name="superCaseInstance">Restrict query to all process instances that are sub process instances of the given case instance. Takes a case instance id. (optional)</param>
        /// <param name="subCaseInstance">Restrict query to all process instances that have the given case instance as a sub case instance. Takes a case instance id. (optional)</param>
        /// <param name="active">Only include active process instances. Value may only be true, as false is the default behavior. (optional, default to false)</param>
        /// <param name="suspended">Only include suspended process instances. Value may only be true, as false is the default behavior. (optional, default to false)</param>
        /// <param name="withIncident">Filter by presence of incidents. Selects only process instances that have an incident. (optional, default to false)</param>
        /// <param name="incidentId">Filter by the incident id. (optional)</param>
        /// <param name="incidentType">Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)</param>
        /// <param name="incidentMessage">Filter by the incident message. Exact match. (optional)</param>
        /// <param name="incidentMessageLike">Filter by the incident message that the parameter is a substring of. (optional)</param>
        /// <param name="tenantIdIn">Filter by a comma-separated list of tenant ids. A process instance must have one of the given tenant ids. (optional)</param>
        /// <param name="withoutTenantId">Only include process instances which belong to no tenant. (optional, default to false)</param>
        /// <param name="processDefinitionWithoutTenantId">Only include process instances which process definition has no tenant id. (optional, default to false)</param>
        /// <param name="activityIdIn">Filter by a comma-separated list of activity ids. A process instance must currently wait in a leaf activity with one of the given activity ids. (optional)</param>
        /// <param name="rootProcessInstances">Restrict the query to all process instances that are top level process instances. (optional, default to false)</param>
        /// <param name="leafProcessInstances">Restrict the query to all process instances that are leaf instances. (i.e. don&#x27;t have any sub instances). (optional, default to false)</param>
        /// <param name="variables">Only include process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)</param>
        /// <param name="variableNamesIgnoreCase">Match all variable names in this query case-insensitively. If set to true variableName and variablename are treated as equal. (optional, default to false)</param>
        /// <param name="variableValuesIgnoreCase">Match all variable values in this query case-insensitively. If set to true variableValue and variablevalue are treated as equal. (optional, default to false)</param>
        /// <returns>ApiResponse of List&lt;ProcessInstanceDto&gt;</returns>
        ApiResponse<List<ProcessInstanceDto>> GetProcessInstancesWithHttpInfo (string sortBy = null, string sortOrder = null, int? firstResult = null, int? maxResults = null, string processInstanceIds = null, string businessKey = null, string businessKeyLike = null, string caseInstanceId = null, string processDefinitionId = null, string processDefinitionKey = null, string processDefinitionKeyIn = null, string processDefinitionKeyNotIn = null, string deploymentId = null, string superProcessInstance = null, string subProcessInstance = null, string superCaseInstance = null, string subCaseInstance = null, bool? active = null, bool? suspended = null, bool? withIncident = null, string incidentId = null, string incidentType = null, string incidentMessage = null, string incidentMessageLike = null, string tenantIdIn = null, bool? withoutTenantId = null, bool? processDefinitionWithoutTenantId = null, string activityIdIn = null, bool? rootProcessInstances = null, bool? leafProcessInstances = null, string variables = null, bool? variableNamesIgnoreCase = null, bool? variableValuesIgnoreCase = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Queries for the number of process instances that fulfill given parameters.
        /// </remarks>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="processInstanceIds">Filter by a comma-separated list of process instance ids. (optional)</param>
        /// <param name="businessKey">Filter by process instance business key. (optional)</param>
        /// <param name="businessKeyLike">Filter by process instance business key that the parameter is a substring of. (optional)</param>
        /// <param name="caseInstanceId">Filter by case instance id. (optional)</param>
        /// <param name="processDefinitionId">Filter by the deployment the id belongs to. (optional)</param>
        /// <param name="processDefinitionKey">Filter by the key of the process definition the instances run on. (optional)</param>
        /// <param name="processDefinitionKeyIn">Filter by a comma-separated list of process definition keys. A process instance must have one of the given process definition keys. (optional)</param>
        /// <param name="processDefinitionKeyNotIn">Exclude instances by a comma-separated list of process definition keys. A process instance must not have one of the given process definition keys. (optional)</param>
        /// <param name="deploymentId">Filter by the deployment the id belongs to. (optional)</param>
        /// <param name="superProcessInstance">Restrict query to all process instances that are sub process instances of the given process instance. Takes a process instance id. (optional)</param>
        /// <param name="subProcessInstance">Restrict query to all process instances that have the given process instance as a sub process instance. Takes a process instance id. (optional)</param>
        /// <param name="superCaseInstance">Restrict query to all process instances that are sub process instances of the given case instance. Takes a case instance id. (optional)</param>
        /// <param name="subCaseInstance">Restrict query to all process instances that have the given case instance as a sub case instance. Takes a case instance id. (optional)</param>
        /// <param name="active">Only include active process instances. Value may only be true, as false is the default behavior. (optional, default to false)</param>
        /// <param name="suspended">Only include suspended process instances. Value may only be true, as false is the default behavior. (optional, default to false)</param>
        /// <param name="withIncident">Filter by presence of incidents. Selects only process instances that have an incident. (optional, default to false)</param>
        /// <param name="incidentId">Filter by the incident id. (optional)</param>
        /// <param name="incidentType">Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)</param>
        /// <param name="incidentMessage">Filter by the incident message. Exact match. (optional)</param>
        /// <param name="incidentMessageLike">Filter by the incident message that the parameter is a substring of. (optional)</param>
        /// <param name="tenantIdIn">Filter by a comma-separated list of tenant ids. A process instance must have one of the given tenant ids. (optional)</param>
        /// <param name="withoutTenantId">Only include process instances which belong to no tenant. (optional, default to false)</param>
        /// <param name="processDefinitionWithoutTenantId">Only include process instances which process definition has no tenant id. (optional, default to false)</param>
        /// <param name="activityIdIn">Filter by a comma-separated list of activity ids. A process instance must currently wait in a leaf activity with one of the given activity ids. (optional)</param>
        /// <param name="rootProcessInstances">Restrict the query to all process instances that are top level process instances. (optional, default to false)</param>
        /// <param name="leafProcessInstances">Restrict the query to all process instances that are leaf instances. (i.e. don&#x27;t have any sub instances). (optional, default to false)</param>
        /// <param name="variables">Only include process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)</param>
        /// <param name="variableNamesIgnoreCase">Match all variable names in this query case-insensitively. If set to true variableName and variablename are treated as equal. (optional, default to false)</param>
        /// <param name="variableValuesIgnoreCase">Match all variable values in this query case-insensitively. If set to true variableValue and variablevalue are treated as equal. (optional, default to false)</param>
        /// <returns>CountResultDto</returns>
        CountResultDto GetProcessInstancesCount (string processInstanceIds = null, string businessKey = null, string businessKeyLike = null, string caseInstanceId = null, string processDefinitionId = null, string processDefinitionKey = null, string processDefinitionKeyIn = null, string processDefinitionKeyNotIn = null, string deploymentId = null, string superProcessInstance = null, string subProcessInstance = null, string superCaseInstance = null, string subCaseInstance = null, bool? active = null, bool? suspended = null, bool? withIncident = null, string incidentId = null, string incidentType = null, string incidentMessage = null, string incidentMessageLike = null, string tenantIdIn = null, bool? withoutTenantId = null, bool? processDefinitionWithoutTenantId = null, string activityIdIn = null, bool? rootProcessInstances = null, bool? leafProcessInstances = null, string variables = null, bool? variableNamesIgnoreCase = null, bool? variableValuesIgnoreCase = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Queries for the number of process instances that fulfill given parameters.
        /// </remarks>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="processInstanceIds">Filter by a comma-separated list of process instance ids. (optional)</param>
        /// <param name="businessKey">Filter by process instance business key. (optional)</param>
        /// <param name="businessKeyLike">Filter by process instance business key that the parameter is a substring of. (optional)</param>
        /// <param name="caseInstanceId">Filter by case instance id. (optional)</param>
        /// <param name="processDefinitionId">Filter by the deployment the id belongs to. (optional)</param>
        /// <param name="processDefinitionKey">Filter by the key of the process definition the instances run on. (optional)</param>
        /// <param name="processDefinitionKeyIn">Filter by a comma-separated list of process definition keys. A process instance must have one of the given process definition keys. (optional)</param>
        /// <param name="processDefinitionKeyNotIn">Exclude instances by a comma-separated list of process definition keys. A process instance must not have one of the given process definition keys. (optional)</param>
        /// <param name="deploymentId">Filter by the deployment the id belongs to. (optional)</param>
        /// <param name="superProcessInstance">Restrict query to all process instances that are sub process instances of the given process instance. Takes a process instance id. (optional)</param>
        /// <param name="subProcessInstance">Restrict query to all process instances that have the given process instance as a sub process instance. Takes a process instance id. (optional)</param>
        /// <param name="superCaseInstance">Restrict query to all process instances that are sub process instances of the given case instance. Takes a case instance id. (optional)</param>
        /// <param name="subCaseInstance">Restrict query to all process instances that have the given case instance as a sub case instance. Takes a case instance id. (optional)</param>
        /// <param name="active">Only include active process instances. Value may only be true, as false is the default behavior. (optional, default to false)</param>
        /// <param name="suspended">Only include suspended process instances. Value may only be true, as false is the default behavior. (optional, default to false)</param>
        /// <param name="withIncident">Filter by presence of incidents. Selects only process instances that have an incident. (optional, default to false)</param>
        /// <param name="incidentId">Filter by the incident id. (optional)</param>
        /// <param name="incidentType">Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)</param>
        /// <param name="incidentMessage">Filter by the incident message. Exact match. (optional)</param>
        /// <param name="incidentMessageLike">Filter by the incident message that the parameter is a substring of. (optional)</param>
        /// <param name="tenantIdIn">Filter by a comma-separated list of tenant ids. A process instance must have one of the given tenant ids. (optional)</param>
        /// <param name="withoutTenantId">Only include process instances which belong to no tenant. (optional, default to false)</param>
        /// <param name="processDefinitionWithoutTenantId">Only include process instances which process definition has no tenant id. (optional, default to false)</param>
        /// <param name="activityIdIn">Filter by a comma-separated list of activity ids. A process instance must currently wait in a leaf activity with one of the given activity ids. (optional)</param>
        /// <param name="rootProcessInstances">Restrict the query to all process instances that are top level process instances. (optional, default to false)</param>
        /// <param name="leafProcessInstances">Restrict the query to all process instances that are leaf instances. (i.e. don&#x27;t have any sub instances). (optional, default to false)</param>
        /// <param name="variables">Only include process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)</param>
        /// <param name="variableNamesIgnoreCase">Match all variable names in this query case-insensitively. If set to true variableName and variablename are treated as equal. (optional, default to false)</param>
        /// <param name="variableValuesIgnoreCase">Match all variable values in this query case-insensitively. If set to true variableValue and variablevalue are treated as equal. (optional, default to false)</param>
        /// <returns>ApiResponse of CountResultDto</returns>
        ApiResponse<CountResultDto> GetProcessInstancesCountWithHttpInfo (string processInstanceIds = null, string businessKey = null, string businessKeyLike = null, string caseInstanceId = null, string processDefinitionId = null, string processDefinitionKey = null, string processDefinitionKeyIn = null, string processDefinitionKeyNotIn = null, string deploymentId = null, string superProcessInstance = null, string subProcessInstance = null, string superCaseInstance = null, string subCaseInstance = null, bool? active = null, bool? suspended = null, bool? withIncident = null, string incidentId = null, string incidentType = null, string incidentMessage = null, string incidentMessageLike = null, string tenantIdIn = null, bool? withoutTenantId = null, bool? processDefinitionWithoutTenantId = null, string activityIdIn = null, bool? rootProcessInstances = null, bool? leafProcessInstances = null, string variables = null, bool? variableNamesIgnoreCase = null, bool? variableValuesIgnoreCase = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Submits a list of modification instructions to change a process instance&#x27;s execution state. A modification instruction is one of the following:  * Starting execution before an activity * Starting execution after an activity on its single outgoing sequence flow * Starting execution on a specific sequence flow * Canceling an activity instance, transition instance, or all instances (activity or transition) for an activity  Instructions are executed immediately and in the order they are provided in this request&#x27;s body. Variables can be provided with every starting instruction.  The exact semantics of modification can be read about in the [User guide](https://docs.camunda.org/manual/develop/user-guide/process-engine/process-instance-modification/).
        /// </remarks>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to modify.</param>
        /// <param name="body"> (optional)</param>
        /// <returns></returns>
        void ModifyProcessInstance (string id, ProcessInstanceModificationDto body = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Submits a list of modification instructions to change a process instance&#x27;s execution state. A modification instruction is one of the following:  * Starting execution before an activity * Starting execution after an activity on its single outgoing sequence flow * Starting execution on a specific sequence flow * Canceling an activity instance, transition instance, or all instances (activity or transition) for an activity  Instructions are executed immediately and in the order they are provided in this request&#x27;s body. Variables can be provided with every starting instruction.  The exact semantics of modification can be read about in the [User guide](https://docs.camunda.org/manual/develop/user-guide/process-engine/process-instance-modification/).
        /// </remarks>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to modify.</param>
        /// <param name="body"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ModifyProcessInstanceWithHttpInfo (string id, ProcessInstanceModificationDto body = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Submits a list of modification instructions to change a process instance&#x27;s execution state async. A modification instruction is one of the following:  * Starting execution before an activity * Starting execution after an activity on its single outgoing sequence flow * Starting execution on a specific sequence flow * Cancelling an activity instance, transition instance, or all instances (activity or transition) for an activity  Instructions are executed asynchronous and in the order they are provided in this request&#x27;s body. Variables can be provided with every starting instruction.  The exact semantics of modification can be read about in the [User guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/process-instance-modification/).
        /// </remarks>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to modify.</param>
        /// <param name="body"> (optional)</param>
        /// <returns>BatchDto</returns>
        BatchDto ModifyProcessInstanceAsyncOperation (string id, ProcessInstanceModificationDto body = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Submits a list of modification instructions to change a process instance&#x27;s execution state async. A modification instruction is one of the following:  * Starting execution before an activity * Starting execution after an activity on its single outgoing sequence flow * Starting execution on a specific sequence flow * Cancelling an activity instance, transition instance, or all instances (activity or transition) for an activity  Instructions are executed asynchronous and in the order they are provided in this request&#x27;s body. Variables can be provided with every starting instruction.  The exact semantics of modification can be read about in the [User guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/process-instance-modification/).
        /// </remarks>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to modify.</param>
        /// <param name="body"> (optional)</param>
        /// <returns>ApiResponse of BatchDto</returns>
        ApiResponse<BatchDto> ModifyProcessInstanceAsyncOperationWithHttpInfo (string id, ProcessInstanceModificationDto body = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Updates or deletes the variables of a process instance by id. Updates precede deletions. So, if a variable is updated AND deleted, the deletion overrides the update.
        /// </remarks>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to set variables for.</param>
        /// <param name="body"> (optional)</param>
        /// <returns></returns>
        void ModifyProcessInstanceVariables (string id, PatchVariablesDto body = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Updates or deletes the variables of a process instance by id. Updates precede deletions. So, if a variable is updated AND deleted, the deletion overrides the update.
        /// </remarks>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to set variables for.</param>
        /// <param name="body"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ModifyProcessInstanceVariablesWithHttpInfo (string id, PatchVariablesDto body = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Queries for process instances that fulfill given parameters through a JSON object. This method is slightly more powerful than the Get Instances method because it allows filtering by multiple process variables of types &#x60;string&#x60;, &#x60;number&#x60; or &#x60;boolean&#x60;.
        /// </remarks>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"> (optional)</param>
        /// <param name="firstResult">Pagination of results. Specifies the index of the first result to return. (optional)</param>
        /// <param name="maxResults">Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)</param>
        /// <returns>List&lt;ProcessInstanceDto&gt;</returns>
        List<ProcessInstanceDto> QueryProcessInstances (ProcessInstanceQueryDto body = null, int? firstResult = null, int? maxResults = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Queries for process instances that fulfill given parameters through a JSON object. This method is slightly more powerful than the Get Instances method because it allows filtering by multiple process variables of types &#x60;string&#x60;, &#x60;number&#x60; or &#x60;boolean&#x60;.
        /// </remarks>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"> (optional)</param>
        /// <param name="firstResult">Pagination of results. Specifies the index of the first result to return. (optional)</param>
        /// <param name="maxResults">Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)</param>
        /// <returns>ApiResponse of List&lt;ProcessInstanceDto&gt;</returns>
        ApiResponse<List<ProcessInstanceDto>> QueryProcessInstancesWithHttpInfo (ProcessInstanceQueryDto body = null, int? firstResult = null, int? maxResults = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Queries for the number of process instances that fulfill the given parameters. This method takes the same message body as the Get Instances (POST) method and therefore it is slightly more powerful than the Get Instance Count method.
        /// </remarks>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"> (optional)</param>
        /// <returns>CountResultDto</returns>
        CountResultDto QueryProcessInstancesCount (ProcessInstanceQueryDto body = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Queries for the number of process instances that fulfill the given parameters. This method takes the same message body as the Get Instances (POST) method and therefore it is slightly more powerful than the Get Instance Count method.
        /// </remarks>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"> (optional)</param>
        /// <returns>ApiResponse of CountResultDto</returns>
        ApiResponse<CountResultDto> QueryProcessInstancesCountWithHttpInfo (ProcessInstanceQueryDto body = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Sets a variable of a given process instance by id.
        /// </remarks>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to set the variable for.</param>
        /// <param name="varName">The name of the variable to set.</param>
        /// <param name="body"> (optional)</param>
        /// <returns></returns>
        void SetProcessInstanceVariable (string id, string varName, VariableValueDto body = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Sets a variable of a given process instance by id.
        /// </remarks>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to set the variable for.</param>
        /// <param name="varName">The name of the variable to set.</param>
        /// <param name="body"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> SetProcessInstanceVariableWithHttpInfo (string id, string varName, VariableValueDto body = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Sets the serialized value for a binary variable or the binary value for a file variable.
        /// </remarks>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to retrieve the variable for.</param>
        /// <param name="varName">The name of the variable to retrieve.</param>
        /// <param name="data"> (optional)</param>
        /// <param name="valueType"> (optional)</param>
        /// <returns></returns>
        void SetProcessInstanceVariableBinary (string id, string varName, byte[] data = null, string valueType = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Sets the serialized value for a binary variable or the binary value for a file variable.
        /// </remarks>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to retrieve the variable for.</param>
        /// <param name="varName">The name of the variable to retrieve.</param>
        /// <param name="data"> (optional)</param>
        /// <param name="valueType"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> SetProcessInstanceVariableBinaryWithHttpInfo (string id, string varName, byte[] data = null, string valueType = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Create a batch to set retries of jobs associated with given processes asynchronously.
        /// </remarks>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Please note that if both processInstances and processInstanceQuery are provided,
        /// then the resulting execution will be performed on the union of these sets.
        /// **Unallowed property**: &#x60;historicProcessInstanceQuery&#x60; (optional)</param>
        /// <returns>BatchDto</returns>
        BatchDto SetRetriesByProcess (SetJobRetriesByProcessDto body = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Create a batch to set retries of jobs associated with given processes asynchronously.
        /// </remarks>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Please note that if both processInstances and processInstanceQuery are provided,
        /// then the resulting execution will be performed on the union of these sets.
        /// **Unallowed property**: &#x60;historicProcessInstanceQuery&#x60; (optional)</param>
        /// <returns>ApiResponse of BatchDto</returns>
        ApiResponse<BatchDto> SetRetriesByProcessWithHttpInfo (SetJobRetriesByProcessDto body = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Create a batch to set retries of jobs asynchronously based on a historic process instance query.
        /// </remarks>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Please note that if both processInstances and historicProcessInstanceQuery are provided,
        /// then the resulting execution will be performed on the union of these sets.
        /// **Unallowed property**: &#x60;processInstanceQuery&#x60; (optional)</param>
        /// <returns>BatchDto</returns>
        BatchDto SetRetriesByProcessHistoricQueryBased (SetJobRetriesByProcessDto body = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Create a batch to set retries of jobs asynchronously based on a historic process instance query.
        /// </remarks>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Please note that if both processInstances and historicProcessInstanceQuery are provided,
        /// then the resulting execution will be performed on the union of these sets.
        /// **Unallowed property**: &#x60;processInstanceQuery&#x60; (optional)</param>
        /// <returns>ApiResponse of BatchDto</returns>
        ApiResponse<BatchDto> SetRetriesByProcessHistoricQueryBasedWithHttpInfo (SetJobRetriesByProcessDto body = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Activates or suspends process instances by providing certain criteria:  # Activate/Suspend Process Instance By Process Definition Id * &#x60;suspend&#x60; * &#x60;processDefinitionId&#x60;  # Activate/Suspend Process Instance By Process Definition Key  * &#x60;suspend&#x60; * &#x60;processDefinitionKey&#x60; * &#x60;processDefinitionTenantId&#x60; * &#x60;processDefinitionWithoutTenantId&#x60;  # Activate/Suspend Process Instance In Group * &#x60;suspend&#x60; * &#x60;processInstanceIds&#x60; * &#x60;processInstanceQuery&#x60; * &#x60;historicProcessInstanceQuery&#x60;
        /// </remarks>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"> (optional)</param>
        /// <returns></returns>
        void UpdateSuspensionState (ProcessInstanceSuspensionStateDto body = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Activates or suspends process instances by providing certain criteria:  # Activate/Suspend Process Instance By Process Definition Id * &#x60;suspend&#x60; * &#x60;processDefinitionId&#x60;  # Activate/Suspend Process Instance By Process Definition Key  * &#x60;suspend&#x60; * &#x60;processDefinitionKey&#x60; * &#x60;processDefinitionTenantId&#x60; * &#x60;processDefinitionWithoutTenantId&#x60;  # Activate/Suspend Process Instance In Group * &#x60;suspend&#x60; * &#x60;processInstanceIds&#x60; * &#x60;processInstanceQuery&#x60; * &#x60;historicProcessInstanceQuery&#x60;
        /// </remarks>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateSuspensionStateWithHttpInfo (ProcessInstanceSuspensionStateDto body = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Activates or suspends process instances asynchronously with a list of process instance ids, a process instance query, and/or a historical process instance query.
        /// </remarks>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"> (optional)</param>
        /// <returns>BatchDto</returns>
        BatchDto UpdateSuspensionStateAsyncOperation (ProcessInstanceSuspensionStateAsyncDto body = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Activates or suspends process instances asynchronously with a list of process instance ids, a process instance query, and/or a historical process instance query.
        /// </remarks>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"> (optional)</param>
        /// <returns>ApiResponse of BatchDto</returns>
        ApiResponse<BatchDto> UpdateSuspensionStateAsyncOperationWithHttpInfo (ProcessInstanceSuspensionStateAsyncDto body = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Activates or suspends a given process instance by id.
        /// </remarks>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to activate or suspend.</param>
        /// <param name="body"> (optional)</param>
        /// <returns></returns>
        void UpdateSuspensionStateById (string id, SuspensionStateDto body = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Activates or suspends a given process instance by id.
        /// </remarks>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to activate or suspend.</param>
        /// <param name="body"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateSuspensionStateByIdWithHttpInfo (string id, SuspensionStateDto body = null);
        #endregion Synchronous Operations
        #region Asynchronous Operations
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Deletes a set of process instances asynchronously (batch) based on a historic process instance query.
        /// </remarks>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">**Unallowed property**: &#x60;processInstanceQuery&#x60; (optional)</param>
        /// <returns>Task of BatchDto</returns>
        System.Threading.Tasks.Task<BatchDto> DeleteAsyncHistoricQueryBasedAsync (DeleteProcessInstancesDto body = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Deletes a set of process instances asynchronously (batch) based on a historic process instance query.
        /// </remarks>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">**Unallowed property**: &#x60;processInstanceQuery&#x60; (optional)</param>
        /// <returns>Task of ApiResponse (BatchDto)</returns>
        System.Threading.Tasks.Task<ApiResponse<BatchDto>> DeleteAsyncHistoricQueryBasedAsyncWithHttpInfo (DeleteProcessInstancesDto body = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Deletes a running process instance by id.
        /// </remarks>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to be deleted.</param>
        /// <param name="skipCustomListeners">If set to true, the custom listeners will be skipped. (optional, default to false)</param>
        /// <param name="skipIoMappings">If set to true, the input/output mappings will be skipped. (optional, default to false)</param>
        /// <param name="skipSubprocesses">If set to true, subprocesses related to deleted processes will be skipped. (optional, default to false)</param>
        /// <param name="failIfNotExists">If set to false, the request will still be successful if the process id is not found. (optional, default to true)</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task DeleteProcessInstanceAsync (string id, bool? skipCustomListeners = null, bool? skipIoMappings = null, bool? skipSubprocesses = null, bool? failIfNotExists = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Deletes a running process instance by id.
        /// </remarks>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to be deleted.</param>
        /// <param name="skipCustomListeners">If set to true, the custom listeners will be skipped. (optional, default to false)</param>
        /// <param name="skipIoMappings">If set to true, the input/output mappings will be skipped. (optional, default to false)</param>
        /// <param name="skipSubprocesses">If set to true, subprocesses related to deleted processes will be skipped. (optional, default to false)</param>
        /// <param name="failIfNotExists">If set to false, the request will still be successful if the process id is not found. (optional, default to true)</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DeleteProcessInstanceAsyncWithHttpInfo (string id, bool? skipCustomListeners = null, bool? skipIoMappings = null, bool? skipSubprocesses = null, bool? failIfNotExists = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Deletes a variable of a process instance by id.
        /// </remarks>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to delete the variable from.</param>
        /// <param name="varName">The name of the variable to delete.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task DeleteProcessInstanceVariableAsync (string id, string varName);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Deletes a variable of a process instance by id.
        /// </remarks>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to delete the variable from.</param>
        /// <param name="varName">The name of the variable to delete.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DeleteProcessInstanceVariableAsyncWithHttpInfo (string id, string varName);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Deletes multiple process instances asynchronously (batch).
        /// </remarks>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">**Unallowed property**: &#x60;historicProcessInstanceQuery&#x60; (optional)</param>
        /// <returns>Task of BatchDto</returns>
        System.Threading.Tasks.Task<BatchDto> DeleteProcessInstancesAsyncOperationAsync (DeleteProcessInstancesDto body = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Deletes multiple process instances asynchronously (batch).
        /// </remarks>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">**Unallowed property**: &#x60;historicProcessInstanceQuery&#x60; (optional)</param>
        /// <returns>Task of ApiResponse (BatchDto)</returns>
        System.Threading.Tasks.Task<ApiResponse<BatchDto>> DeleteProcessInstancesAsyncOperationAsyncWithHttpInfo (DeleteProcessInstancesDto body = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Retrieves an Activity Instance (Tree) for a given process instance by id.
        /// </remarks>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance for which the activity instance should be retrieved.</param>
        /// <returns>Task of ActivityInstanceDto</returns>
        System.Threading.Tasks.Task<ActivityInstanceDto> GetActivityInstanceTreeAsync (string id);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Retrieves an Activity Instance (Tree) for a given process instance by id.
        /// </remarks>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance for which the activity instance should be retrieved.</param>
        /// <returns>Task of ApiResponse (ActivityInstanceDto)</returns>
        System.Threading.Tasks.Task<ApiResponse<ActivityInstanceDto>> GetActivityInstanceTreeAsyncWithHttpInfo (string id);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Retrieves a variable of a given process instance by id.
        /// </remarks>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to retrieve the variable for.</param>
        /// <param name="varName">The name of the variable to retrieve.</param>
        /// <param name="deserializeValue">Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine. (optional, default to true)</param>
        /// <returns>Task of VariableValueDto</returns>
        System.Threading.Tasks.Task<VariableValueDto> GetProcessInstanceVariableAsync (string id, string varName, bool? deserializeValue = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Retrieves a variable of a given process instance by id.
        /// </remarks>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to retrieve the variable for.</param>
        /// <param name="varName">The name of the variable to retrieve.</param>
        /// <param name="deserializeValue">Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine. (optional, default to true)</param>
        /// <returns>Task of ApiResponse (VariableValueDto)</returns>
        System.Threading.Tasks.Task<ApiResponse<VariableValueDto>> GetProcessInstanceVariableAsyncWithHttpInfo (string id, string varName, bool? deserializeValue = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Retrieves the content of a Process Variable by the Process Instance id and the Process Variable name. Applicable for byte array or file Process Variables.
        /// </remarks>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to retrieve the variable for.</param>
        /// <param name="varName">The name of the variable to retrieve.</param>
        /// <returns>Task of byte[]</returns>
        System.Threading.Tasks.Task<byte[]> GetProcessInstanceVariableBinaryAsync (string id, string varName);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Retrieves the content of a Process Variable by the Process Instance id and the Process Variable name. Applicable for byte array or file Process Variables.
        /// </remarks>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to retrieve the variable for.</param>
        /// <param name="varName">The name of the variable to retrieve.</param>
        /// <returns>Task of ApiResponse (byte[])</returns>
        System.Threading.Tasks.Task<ApiResponse<byte[]>> GetProcessInstanceVariableBinaryAsyncWithHttpInfo (string id, string varName);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Retrieves all variables of a given process instance by id.
        /// </remarks>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to retrieve the variables from.</param>
        /// <param name="deserializeValue">Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine. (optional, default to true)</param>
        /// <returns>Task of Dictionary&lt;string, VariableValueDto&gt;</returns>
        System.Threading.Tasks.Task<Dictionary<string, VariableValueDto>> GetProcessInstanceVariablesAsync (string id, bool? deserializeValue = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Retrieves all variables of a given process instance by id.
        /// </remarks>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to retrieve the variables from.</param>
        /// <param name="deserializeValue">Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine. (optional, default to true)</param>
        /// <returns>Task of ApiResponse (Dictionary&lt;string, VariableValueDto&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<Dictionary<string, VariableValueDto>>> GetProcessInstanceVariablesAsyncWithHttpInfo (string id, bool? deserializeValue = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Queries for process instances that fulfill given parameters. Parameters may be static as well as dynamic runtime properties of process instances. The size of the result set can be retrieved by using the Get Instance Count method.
        /// </remarks>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sortBy">Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter. (optional)</param>
        /// <param name="sortOrder">Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter. (optional)</param>
        /// <param name="firstResult">Pagination of results. Specifies the index of the first result to return. (optional)</param>
        /// <param name="maxResults">Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)</param>
        /// <param name="processInstanceIds">Filter by a comma-separated list of process instance ids. (optional)</param>
        /// <param name="businessKey">Filter by process instance business key. (optional)</param>
        /// <param name="businessKeyLike">Filter by process instance business key that the parameter is a substring of. (optional)</param>
        /// <param name="caseInstanceId">Filter by case instance id. (optional)</param>
        /// <param name="processDefinitionId">Filter by the deployment the id belongs to. (optional)</param>
        /// <param name="processDefinitionKey">Filter by the key of the process definition the instances run on. (optional)</param>
        /// <param name="processDefinitionKeyIn">Filter by a comma-separated list of process definition keys. A process instance must have one of the given process definition keys. (optional)</param>
        /// <param name="processDefinitionKeyNotIn">Exclude instances by a comma-separated list of process definition keys. A process instance must not have one of the given process definition keys. (optional)</param>
        /// <param name="deploymentId">Filter by the deployment the id belongs to. (optional)</param>
        /// <param name="superProcessInstance">Restrict query to all process instances that are sub process instances of the given process instance. Takes a process instance id. (optional)</param>
        /// <param name="subProcessInstance">Restrict query to all process instances that have the given process instance as a sub process instance. Takes a process instance id. (optional)</param>
        /// <param name="superCaseInstance">Restrict query to all process instances that are sub process instances of the given case instance. Takes a case instance id. (optional)</param>
        /// <param name="subCaseInstance">Restrict query to all process instances that have the given case instance as a sub case instance. Takes a case instance id. (optional)</param>
        /// <param name="active">Only include active process instances. Value may only be true, as false is the default behavior. (optional, default to false)</param>
        /// <param name="suspended">Only include suspended process instances. Value may only be true, as false is the default behavior. (optional, default to false)</param>
        /// <param name="withIncident">Filter by presence of incidents. Selects only process instances that have an incident. (optional, default to false)</param>
        /// <param name="incidentId">Filter by the incident id. (optional)</param>
        /// <param name="incidentType">Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)</param>
        /// <param name="incidentMessage">Filter by the incident message. Exact match. (optional)</param>
        /// <param name="incidentMessageLike">Filter by the incident message that the parameter is a substring of. (optional)</param>
        /// <param name="tenantIdIn">Filter by a comma-separated list of tenant ids. A process instance must have one of the given tenant ids. (optional)</param>
        /// <param name="withoutTenantId">Only include process instances which belong to no tenant. (optional, default to false)</param>
        /// <param name="processDefinitionWithoutTenantId">Only include process instances which process definition has no tenant id. (optional, default to false)</param>
        /// <param name="activityIdIn">Filter by a comma-separated list of activity ids. A process instance must currently wait in a leaf activity with one of the given activity ids. (optional)</param>
        /// <param name="rootProcessInstances">Restrict the query to all process instances that are top level process instances. (optional, default to false)</param>
        /// <param name="leafProcessInstances">Restrict the query to all process instances that are leaf instances. (i.e. don&#x27;t have any sub instances). (optional, default to false)</param>
        /// <param name="variables">Only include process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)</param>
        /// <param name="variableNamesIgnoreCase">Match all variable names in this query case-insensitively. If set to true variableName and variablename are treated as equal. (optional, default to false)</param>
        /// <param name="variableValuesIgnoreCase">Match all variable values in this query case-insensitively. If set to true variableValue and variablevalue are treated as equal. (optional, default to false)</param>
        /// <returns>Task of List&lt;ProcessInstanceDto&gt;</returns>
        System.Threading.Tasks.Task<List<ProcessInstanceDto>> GetProcessInstancesAsync (string sortBy = null, string sortOrder = null, int? firstResult = null, int? maxResults = null, string processInstanceIds = null, string businessKey = null, string businessKeyLike = null, string caseInstanceId = null, string processDefinitionId = null, string processDefinitionKey = null, string processDefinitionKeyIn = null, string processDefinitionKeyNotIn = null, string deploymentId = null, string superProcessInstance = null, string subProcessInstance = null, string superCaseInstance = null, string subCaseInstance = null, bool? active = null, bool? suspended = null, bool? withIncident = null, string incidentId = null, string incidentType = null, string incidentMessage = null, string incidentMessageLike = null, string tenantIdIn = null, bool? withoutTenantId = null, bool? processDefinitionWithoutTenantId = null, string activityIdIn = null, bool? rootProcessInstances = null, bool? leafProcessInstances = null, string variables = null, bool? variableNamesIgnoreCase = null, bool? variableValuesIgnoreCase = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Queries for process instances that fulfill given parameters. Parameters may be static as well as dynamic runtime properties of process instances. The size of the result set can be retrieved by using the Get Instance Count method.
        /// </remarks>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sortBy">Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter. (optional)</param>
        /// <param name="sortOrder">Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter. (optional)</param>
        /// <param name="firstResult">Pagination of results. Specifies the index of the first result to return. (optional)</param>
        /// <param name="maxResults">Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)</param>
        /// <param name="processInstanceIds">Filter by a comma-separated list of process instance ids. (optional)</param>
        /// <param name="businessKey">Filter by process instance business key. (optional)</param>
        /// <param name="businessKeyLike">Filter by process instance business key that the parameter is a substring of. (optional)</param>
        /// <param name="caseInstanceId">Filter by case instance id. (optional)</param>
        /// <param name="processDefinitionId">Filter by the deployment the id belongs to. (optional)</param>
        /// <param name="processDefinitionKey">Filter by the key of the process definition the instances run on. (optional)</param>
        /// <param name="processDefinitionKeyIn">Filter by a comma-separated list of process definition keys. A process instance must have one of the given process definition keys. (optional)</param>
        /// <param name="processDefinitionKeyNotIn">Exclude instances by a comma-separated list of process definition keys. A process instance must not have one of the given process definition keys. (optional)</param>
        /// <param name="deploymentId">Filter by the deployment the id belongs to. (optional)</param>
        /// <param name="superProcessInstance">Restrict query to all process instances that are sub process instances of the given process instance. Takes a process instance id. (optional)</param>
        /// <param name="subProcessInstance">Restrict query to all process instances that have the given process instance as a sub process instance. Takes a process instance id. (optional)</param>
        /// <param name="superCaseInstance">Restrict query to all process instances that are sub process instances of the given case instance. Takes a case instance id. (optional)</param>
        /// <param name="subCaseInstance">Restrict query to all process instances that have the given case instance as a sub case instance. Takes a case instance id. (optional)</param>
        /// <param name="active">Only include active process instances. Value may only be true, as false is the default behavior. (optional, default to false)</param>
        /// <param name="suspended">Only include suspended process instances. Value may only be true, as false is the default behavior. (optional, default to false)</param>
        /// <param name="withIncident">Filter by presence of incidents. Selects only process instances that have an incident. (optional, default to false)</param>
        /// <param name="incidentId">Filter by the incident id. (optional)</param>
        /// <param name="incidentType">Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)</param>
        /// <param name="incidentMessage">Filter by the incident message. Exact match. (optional)</param>
        /// <param name="incidentMessageLike">Filter by the incident message that the parameter is a substring of. (optional)</param>
        /// <param name="tenantIdIn">Filter by a comma-separated list of tenant ids. A process instance must have one of the given tenant ids. (optional)</param>
        /// <param name="withoutTenantId">Only include process instances which belong to no tenant. (optional, default to false)</param>
        /// <param name="processDefinitionWithoutTenantId">Only include process instances which process definition has no tenant id. (optional, default to false)</param>
        /// <param name="activityIdIn">Filter by a comma-separated list of activity ids. A process instance must currently wait in a leaf activity with one of the given activity ids. (optional)</param>
        /// <param name="rootProcessInstances">Restrict the query to all process instances that are top level process instances. (optional, default to false)</param>
        /// <param name="leafProcessInstances">Restrict the query to all process instances that are leaf instances. (i.e. don&#x27;t have any sub instances). (optional, default to false)</param>
        /// <param name="variables">Only include process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)</param>
        /// <param name="variableNamesIgnoreCase">Match all variable names in this query case-insensitively. If set to true variableName and variablename are treated as equal. (optional, default to false)</param>
        /// <param name="variableValuesIgnoreCase">Match all variable values in this query case-insensitively. If set to true variableValue and variablevalue are treated as equal. (optional, default to false)</param>
        /// <returns>Task of ApiResponse (List&lt;ProcessInstanceDto&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<ProcessInstanceDto>>> GetProcessInstancesAsyncWithHttpInfo (string sortBy = null, string sortOrder = null, int? firstResult = null, int? maxResults = null, string processInstanceIds = null, string businessKey = null, string businessKeyLike = null, string caseInstanceId = null, string processDefinitionId = null, string processDefinitionKey = null, string processDefinitionKeyIn = null, string processDefinitionKeyNotIn = null, string deploymentId = null, string superProcessInstance = null, string subProcessInstance = null, string superCaseInstance = null, string subCaseInstance = null, bool? active = null, bool? suspended = null, bool? withIncident = null, string incidentId = null, string incidentType = null, string incidentMessage = null, string incidentMessageLike = null, string tenantIdIn = null, bool? withoutTenantId = null, bool? processDefinitionWithoutTenantId = null, string activityIdIn = null, bool? rootProcessInstances = null, bool? leafProcessInstances = null, string variables = null, bool? variableNamesIgnoreCase = null, bool? variableValuesIgnoreCase = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Queries for the number of process instances that fulfill given parameters.
        /// </remarks>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="processInstanceIds">Filter by a comma-separated list of process instance ids. (optional)</param>
        /// <param name="businessKey">Filter by process instance business key. (optional)</param>
        /// <param name="businessKeyLike">Filter by process instance business key that the parameter is a substring of. (optional)</param>
        /// <param name="caseInstanceId">Filter by case instance id. (optional)</param>
        /// <param name="processDefinitionId">Filter by the deployment the id belongs to. (optional)</param>
        /// <param name="processDefinitionKey">Filter by the key of the process definition the instances run on. (optional)</param>
        /// <param name="processDefinitionKeyIn">Filter by a comma-separated list of process definition keys. A process instance must have one of the given process definition keys. (optional)</param>
        /// <param name="processDefinitionKeyNotIn">Exclude instances by a comma-separated list of process definition keys. A process instance must not have one of the given process definition keys. (optional)</param>
        /// <param name="deploymentId">Filter by the deployment the id belongs to. (optional)</param>
        /// <param name="superProcessInstance">Restrict query to all process instances that are sub process instances of the given process instance. Takes a process instance id. (optional)</param>
        /// <param name="subProcessInstance">Restrict query to all process instances that have the given process instance as a sub process instance. Takes a process instance id. (optional)</param>
        /// <param name="superCaseInstance">Restrict query to all process instances that are sub process instances of the given case instance. Takes a case instance id. (optional)</param>
        /// <param name="subCaseInstance">Restrict query to all process instances that have the given case instance as a sub case instance. Takes a case instance id. (optional)</param>
        /// <param name="active">Only include active process instances. Value may only be true, as false is the default behavior. (optional, default to false)</param>
        /// <param name="suspended">Only include suspended process instances. Value may only be true, as false is the default behavior. (optional, default to false)</param>
        /// <param name="withIncident">Filter by presence of incidents. Selects only process instances that have an incident. (optional, default to false)</param>
        /// <param name="incidentId">Filter by the incident id. (optional)</param>
        /// <param name="incidentType">Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)</param>
        /// <param name="incidentMessage">Filter by the incident message. Exact match. (optional)</param>
        /// <param name="incidentMessageLike">Filter by the incident message that the parameter is a substring of. (optional)</param>
        /// <param name="tenantIdIn">Filter by a comma-separated list of tenant ids. A process instance must have one of the given tenant ids. (optional)</param>
        /// <param name="withoutTenantId">Only include process instances which belong to no tenant. (optional, default to false)</param>
        /// <param name="processDefinitionWithoutTenantId">Only include process instances which process definition has no tenant id. (optional, default to false)</param>
        /// <param name="activityIdIn">Filter by a comma-separated list of activity ids. A process instance must currently wait in a leaf activity with one of the given activity ids. (optional)</param>
        /// <param name="rootProcessInstances">Restrict the query to all process instances that are top level process instances. (optional, default to false)</param>
        /// <param name="leafProcessInstances">Restrict the query to all process instances that are leaf instances. (i.e. don&#x27;t have any sub instances). (optional, default to false)</param>
        /// <param name="variables">Only include process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)</param>
        /// <param name="variableNamesIgnoreCase">Match all variable names in this query case-insensitively. If set to true variableName and variablename are treated as equal. (optional, default to false)</param>
        /// <param name="variableValuesIgnoreCase">Match all variable values in this query case-insensitively. If set to true variableValue and variablevalue are treated as equal. (optional, default to false)</param>
        /// <returns>Task of CountResultDto</returns>
        System.Threading.Tasks.Task<CountResultDto> GetProcessInstancesCountAsync (string processInstanceIds = null, string businessKey = null, string businessKeyLike = null, string caseInstanceId = null, string processDefinitionId = null, string processDefinitionKey = null, string processDefinitionKeyIn = null, string processDefinitionKeyNotIn = null, string deploymentId = null, string superProcessInstance = null, string subProcessInstance = null, string superCaseInstance = null, string subCaseInstance = null, bool? active = null, bool? suspended = null, bool? withIncident = null, string incidentId = null, string incidentType = null, string incidentMessage = null, string incidentMessageLike = null, string tenantIdIn = null, bool? withoutTenantId = null, bool? processDefinitionWithoutTenantId = null, string activityIdIn = null, bool? rootProcessInstances = null, bool? leafProcessInstances = null, string variables = null, bool? variableNamesIgnoreCase = null, bool? variableValuesIgnoreCase = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Queries for the number of process instances that fulfill given parameters.
        /// </remarks>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="processInstanceIds">Filter by a comma-separated list of process instance ids. (optional)</param>
        /// <param name="businessKey">Filter by process instance business key. (optional)</param>
        /// <param name="businessKeyLike">Filter by process instance business key that the parameter is a substring of. (optional)</param>
        /// <param name="caseInstanceId">Filter by case instance id. (optional)</param>
        /// <param name="processDefinitionId">Filter by the deployment the id belongs to. (optional)</param>
        /// <param name="processDefinitionKey">Filter by the key of the process definition the instances run on. (optional)</param>
        /// <param name="processDefinitionKeyIn">Filter by a comma-separated list of process definition keys. A process instance must have one of the given process definition keys. (optional)</param>
        /// <param name="processDefinitionKeyNotIn">Exclude instances by a comma-separated list of process definition keys. A process instance must not have one of the given process definition keys. (optional)</param>
        /// <param name="deploymentId">Filter by the deployment the id belongs to. (optional)</param>
        /// <param name="superProcessInstance">Restrict query to all process instances that are sub process instances of the given process instance. Takes a process instance id. (optional)</param>
        /// <param name="subProcessInstance">Restrict query to all process instances that have the given process instance as a sub process instance. Takes a process instance id. (optional)</param>
        /// <param name="superCaseInstance">Restrict query to all process instances that are sub process instances of the given case instance. Takes a case instance id. (optional)</param>
        /// <param name="subCaseInstance">Restrict query to all process instances that have the given case instance as a sub case instance. Takes a case instance id. (optional)</param>
        /// <param name="active">Only include active process instances. Value may only be true, as false is the default behavior. (optional, default to false)</param>
        /// <param name="suspended">Only include suspended process instances. Value may only be true, as false is the default behavior. (optional, default to false)</param>
        /// <param name="withIncident">Filter by presence of incidents. Selects only process instances that have an incident. (optional, default to false)</param>
        /// <param name="incidentId">Filter by the incident id. (optional)</param>
        /// <param name="incidentType">Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)</param>
        /// <param name="incidentMessage">Filter by the incident message. Exact match. (optional)</param>
        /// <param name="incidentMessageLike">Filter by the incident message that the parameter is a substring of. (optional)</param>
        /// <param name="tenantIdIn">Filter by a comma-separated list of tenant ids. A process instance must have one of the given tenant ids. (optional)</param>
        /// <param name="withoutTenantId">Only include process instances which belong to no tenant. (optional, default to false)</param>
        /// <param name="processDefinitionWithoutTenantId">Only include process instances which process definition has no tenant id. (optional, default to false)</param>
        /// <param name="activityIdIn">Filter by a comma-separated list of activity ids. A process instance must currently wait in a leaf activity with one of the given activity ids. (optional)</param>
        /// <param name="rootProcessInstances">Restrict the query to all process instances that are top level process instances. (optional, default to false)</param>
        /// <param name="leafProcessInstances">Restrict the query to all process instances that are leaf instances. (i.e. don&#x27;t have any sub instances). (optional, default to false)</param>
        /// <param name="variables">Only include process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)</param>
        /// <param name="variableNamesIgnoreCase">Match all variable names in this query case-insensitively. If set to true variableName and variablename are treated as equal. (optional, default to false)</param>
        /// <param name="variableValuesIgnoreCase">Match all variable values in this query case-insensitively. If set to true variableValue and variablevalue are treated as equal. (optional, default to false)</param>
        /// <returns>Task of ApiResponse (CountResultDto)</returns>
        System.Threading.Tasks.Task<ApiResponse<CountResultDto>> GetProcessInstancesCountAsyncWithHttpInfo (string processInstanceIds = null, string businessKey = null, string businessKeyLike = null, string caseInstanceId = null, string processDefinitionId = null, string processDefinitionKey = null, string processDefinitionKeyIn = null, string processDefinitionKeyNotIn = null, string deploymentId = null, string superProcessInstance = null, string subProcessInstance = null, string superCaseInstance = null, string subCaseInstance = null, bool? active = null, bool? suspended = null, bool? withIncident = null, string incidentId = null, string incidentType = null, string incidentMessage = null, string incidentMessageLike = null, string tenantIdIn = null, bool? withoutTenantId = null, bool? processDefinitionWithoutTenantId = null, string activityIdIn = null, bool? rootProcessInstances = null, bool? leafProcessInstances = null, string variables = null, bool? variableNamesIgnoreCase = null, bool? variableValuesIgnoreCase = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Submits a list of modification instructions to change a process instance&#x27;s execution state. A modification instruction is one of the following:  * Starting execution before an activity * Starting execution after an activity on its single outgoing sequence flow * Starting execution on a specific sequence flow * Canceling an activity instance, transition instance, or all instances (activity or transition) for an activity  Instructions are executed immediately and in the order they are provided in this request&#x27;s body. Variables can be provided with every starting instruction.  The exact semantics of modification can be read about in the [User guide](https://docs.camunda.org/manual/develop/user-guide/process-engine/process-instance-modification/).
        /// </remarks>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to modify.</param>
        /// <param name="body"> (optional)</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task ModifyProcessInstanceAsync (string id, ProcessInstanceModificationDto body = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Submits a list of modification instructions to change a process instance&#x27;s execution state. A modification instruction is one of the following:  * Starting execution before an activity * Starting execution after an activity on its single outgoing sequence flow * Starting execution on a specific sequence flow * Canceling an activity instance, transition instance, or all instances (activity or transition) for an activity  Instructions are executed immediately and in the order they are provided in this request&#x27;s body. Variables can be provided with every starting instruction.  The exact semantics of modification can be read about in the [User guide](https://docs.camunda.org/manual/develop/user-guide/process-engine/process-instance-modification/).
        /// </remarks>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to modify.</param>
        /// <param name="body"> (optional)</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> ModifyProcessInstanceAsyncWithHttpInfo (string id, ProcessInstanceModificationDto body = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Submits a list of modification instructions to change a process instance&#x27;s execution state async. A modification instruction is one of the following:  * Starting execution before an activity * Starting execution after an activity on its single outgoing sequence flow * Starting execution on a specific sequence flow * Cancelling an activity instance, transition instance, or all instances (activity or transition) for an activity  Instructions are executed asynchronous and in the order they are provided in this request&#x27;s body. Variables can be provided with every starting instruction.  The exact semantics of modification can be read about in the [User guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/process-instance-modification/).
        /// </remarks>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to modify.</param>
        /// <param name="body"> (optional)</param>
        /// <returns>Task of BatchDto</returns>
        System.Threading.Tasks.Task<BatchDto> ModifyProcessInstanceAsyncOperationAsync (string id, ProcessInstanceModificationDto body = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Submits a list of modification instructions to change a process instance&#x27;s execution state async. A modification instruction is one of the following:  * Starting execution before an activity * Starting execution after an activity on its single outgoing sequence flow * Starting execution on a specific sequence flow * Cancelling an activity instance, transition instance, or all instances (activity or transition) for an activity  Instructions are executed asynchronous and in the order they are provided in this request&#x27;s body. Variables can be provided with every starting instruction.  The exact semantics of modification can be read about in the [User guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/process-instance-modification/).
        /// </remarks>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to modify.</param>
        /// <param name="body"> (optional)</param>
        /// <returns>Task of ApiResponse (BatchDto)</returns>
        System.Threading.Tasks.Task<ApiResponse<BatchDto>> ModifyProcessInstanceAsyncOperationAsyncWithHttpInfo (string id, ProcessInstanceModificationDto body = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Updates or deletes the variables of a process instance by id. Updates precede deletions. So, if a variable is updated AND deleted, the deletion overrides the update.
        /// </remarks>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to set variables for.</param>
        /// <param name="body"> (optional)</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task ModifyProcessInstanceVariablesAsync (string id, PatchVariablesDto body = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Updates or deletes the variables of a process instance by id. Updates precede deletions. So, if a variable is updated AND deleted, the deletion overrides the update.
        /// </remarks>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to set variables for.</param>
        /// <param name="body"> (optional)</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> ModifyProcessInstanceVariablesAsyncWithHttpInfo (string id, PatchVariablesDto body = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Queries for process instances that fulfill given parameters through a JSON object. This method is slightly more powerful than the Get Instances method because it allows filtering by multiple process variables of types &#x60;string&#x60;, &#x60;number&#x60; or &#x60;boolean&#x60;.
        /// </remarks>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"> (optional)</param>
        /// <param name="firstResult">Pagination of results. Specifies the index of the first result to return. (optional)</param>
        /// <param name="maxResults">Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)</param>
        /// <returns>Task of List&lt;ProcessInstanceDto&gt;</returns>
        System.Threading.Tasks.Task<List<ProcessInstanceDto>> QueryProcessInstancesAsync (ProcessInstanceQueryDto body = null, int? firstResult = null, int? maxResults = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Queries for process instances that fulfill given parameters through a JSON object. This method is slightly more powerful than the Get Instances method because it allows filtering by multiple process variables of types &#x60;string&#x60;, &#x60;number&#x60; or &#x60;boolean&#x60;.
        /// </remarks>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"> (optional)</param>
        /// <param name="firstResult">Pagination of results. Specifies the index of the first result to return. (optional)</param>
        /// <param name="maxResults">Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;ProcessInstanceDto&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<ProcessInstanceDto>>> QueryProcessInstancesAsyncWithHttpInfo (ProcessInstanceQueryDto body = null, int? firstResult = null, int? maxResults = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Queries for the number of process instances that fulfill the given parameters. This method takes the same message body as the Get Instances (POST) method and therefore it is slightly more powerful than the Get Instance Count method.
        /// </remarks>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"> (optional)</param>
        /// <returns>Task of CountResultDto</returns>
        System.Threading.Tasks.Task<CountResultDto> QueryProcessInstancesCountAsync (ProcessInstanceQueryDto body = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Queries for the number of process instances that fulfill the given parameters. This method takes the same message body as the Get Instances (POST) method and therefore it is slightly more powerful than the Get Instance Count method.
        /// </remarks>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"> (optional)</param>
        /// <returns>Task of ApiResponse (CountResultDto)</returns>
        System.Threading.Tasks.Task<ApiResponse<CountResultDto>> QueryProcessInstancesCountAsyncWithHttpInfo (ProcessInstanceQueryDto body = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Sets a variable of a given process instance by id.
        /// </remarks>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to set the variable for.</param>
        /// <param name="varName">The name of the variable to set.</param>
        /// <param name="body"> (optional)</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task SetProcessInstanceVariableAsync (string id, string varName, VariableValueDto body = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Sets a variable of a given process instance by id.
        /// </remarks>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to set the variable for.</param>
        /// <param name="varName">The name of the variable to set.</param>
        /// <param name="body"> (optional)</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> SetProcessInstanceVariableAsyncWithHttpInfo (string id, string varName, VariableValueDto body = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Sets the serialized value for a binary variable or the binary value for a file variable.
        /// </remarks>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to retrieve the variable for.</param>
        /// <param name="varName">The name of the variable to retrieve.</param>
        /// <param name="data"> (optional)</param>
        /// <param name="valueType"> (optional)</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task SetProcessInstanceVariableBinaryAsync (string id, string varName, byte[] data = null, string valueType = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Sets the serialized value for a binary variable or the binary value for a file variable.
        /// </remarks>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to retrieve the variable for.</param>
        /// <param name="varName">The name of the variable to retrieve.</param>
        /// <param name="data"> (optional)</param>
        /// <param name="valueType"> (optional)</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> SetProcessInstanceVariableBinaryAsyncWithHttpInfo (string id, string varName, byte[] data = null, string valueType = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Create a batch to set retries of jobs associated with given processes asynchronously.
        /// </remarks>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Please note that if both processInstances and processInstanceQuery are provided,
        /// then the resulting execution will be performed on the union of these sets.
        /// **Unallowed property**: &#x60;historicProcessInstanceQuery&#x60; (optional)</param>
        /// <returns>Task of BatchDto</returns>
        System.Threading.Tasks.Task<BatchDto> SetRetriesByProcessAsync (SetJobRetriesByProcessDto body = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Create a batch to set retries of jobs associated with given processes asynchronously.
        /// </remarks>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Please note that if both processInstances and processInstanceQuery are provided,
        /// then the resulting execution will be performed on the union of these sets.
        /// **Unallowed property**: &#x60;historicProcessInstanceQuery&#x60; (optional)</param>
        /// <returns>Task of ApiResponse (BatchDto)</returns>
        System.Threading.Tasks.Task<ApiResponse<BatchDto>> SetRetriesByProcessAsyncWithHttpInfo (SetJobRetriesByProcessDto body = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Create a batch to set retries of jobs asynchronously based on a historic process instance query.
        /// </remarks>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Please note that if both processInstances and historicProcessInstanceQuery are provided,
        /// then the resulting execution will be performed on the union of these sets.
        /// **Unallowed property**: &#x60;processInstanceQuery&#x60; (optional)</param>
        /// <returns>Task of BatchDto</returns>
        System.Threading.Tasks.Task<BatchDto> SetRetriesByProcessHistoricQueryBasedAsync (SetJobRetriesByProcessDto body = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Create a batch to set retries of jobs asynchronously based on a historic process instance query.
        /// </remarks>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Please note that if both processInstances and historicProcessInstanceQuery are provided,
        /// then the resulting execution will be performed on the union of these sets.
        /// **Unallowed property**: &#x60;processInstanceQuery&#x60; (optional)</param>
        /// <returns>Task of ApiResponse (BatchDto)</returns>
        System.Threading.Tasks.Task<ApiResponse<BatchDto>> SetRetriesByProcessHistoricQueryBasedAsyncWithHttpInfo (SetJobRetriesByProcessDto body = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Activates or suspends process instances by providing certain criteria:  # Activate/Suspend Process Instance By Process Definition Id * &#x60;suspend&#x60; * &#x60;processDefinitionId&#x60;  # Activate/Suspend Process Instance By Process Definition Key  * &#x60;suspend&#x60; * &#x60;processDefinitionKey&#x60; * &#x60;processDefinitionTenantId&#x60; * &#x60;processDefinitionWithoutTenantId&#x60;  # Activate/Suspend Process Instance In Group * &#x60;suspend&#x60; * &#x60;processInstanceIds&#x60; * &#x60;processInstanceQuery&#x60; * &#x60;historicProcessInstanceQuery&#x60;
        /// </remarks>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"> (optional)</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task UpdateSuspensionStateAsync (ProcessInstanceSuspensionStateDto body = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Activates or suspends process instances by providing certain criteria:  # Activate/Suspend Process Instance By Process Definition Id * &#x60;suspend&#x60; * &#x60;processDefinitionId&#x60;  # Activate/Suspend Process Instance By Process Definition Key  * &#x60;suspend&#x60; * &#x60;processDefinitionKey&#x60; * &#x60;processDefinitionTenantId&#x60; * &#x60;processDefinitionWithoutTenantId&#x60;  # Activate/Suspend Process Instance In Group * &#x60;suspend&#x60; * &#x60;processInstanceIds&#x60; * &#x60;processInstanceQuery&#x60; * &#x60;historicProcessInstanceQuery&#x60;
        /// </remarks>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"> (optional)</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> UpdateSuspensionStateAsyncWithHttpInfo (ProcessInstanceSuspensionStateDto body = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Activates or suspends process instances asynchronously with a list of process instance ids, a process instance query, and/or a historical process instance query.
        /// </remarks>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"> (optional)</param>
        /// <returns>Task of BatchDto</returns>
        System.Threading.Tasks.Task<BatchDto> UpdateSuspensionStateAsyncOperationAsync (ProcessInstanceSuspensionStateAsyncDto body = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Activates or suspends process instances asynchronously with a list of process instance ids, a process instance query, and/or a historical process instance query.
        /// </remarks>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"> (optional)</param>
        /// <returns>Task of ApiResponse (BatchDto)</returns>
        System.Threading.Tasks.Task<ApiResponse<BatchDto>> UpdateSuspensionStateAsyncOperationAsyncWithHttpInfo (ProcessInstanceSuspensionStateAsyncDto body = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Activates or suspends a given process instance by id.
        /// </remarks>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to activate or suspend.</param>
        /// <param name="body"> (optional)</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task UpdateSuspensionStateByIdAsync (string id, SuspensionStateDto body = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Activates or suspends a given process instance by id.
        /// </remarks>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to activate or suspend.</param>
        /// <param name="body"> (optional)</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> UpdateSuspensionStateByIdAsyncWithHttpInfo (string id, SuspensionStateDto body = null);
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
        public partial class ProcessInstanceApi : IProcessInstanceApi
    {
        private Camunda.Client.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="ProcessInstanceApi"/> class.
        /// </summary>
        /// <returns></returns>
        public ProcessInstanceApi(String basePath)
        {
            this.Configuration = new Camunda.Client.Client.Configuration { BasePath = basePath };

            ExceptionFactory = Camunda.Client.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ProcessInstanceApi"/> class
        /// </summary>
        /// <returns></returns>
        public ProcessInstanceApi()
        {
            this.Configuration = Camunda.Client.Client.Configuration.Default;

            ExceptionFactory = Camunda.Client.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ProcessInstanceApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public ProcessInstanceApi(Camunda.Client.Client.Configuration configuration = null)
        {
            if (configuration == null) // use the default one in Configuration
                this.Configuration = Camunda.Client.Client.Configuration.Default;
            else
                this.Configuration = configuration;

            ExceptionFactory = Camunda.Client.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public String GetBasePath()
        {
            return this.Configuration.ApiClient.RestClient.BaseUrl.ToString();
        }

        /// <summary>
        /// Sets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        [Obsolete("SetBasePath is deprecated, please do 'Configuration.ApiClient = new ApiClient(\"http://new-path\")' instead.")]
        public void SetBasePath(String basePath)
        {
            // do nothing
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public Camunda.Client.Client.Configuration Configuration {get; set;}

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public Camunda.Client.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// Gets the default header.
        /// </summary>
        /// <returns>Dictionary of HTTP header</returns>
        [Obsolete("DefaultHeader is deprecated, please use Configuration.DefaultHeader instead.")]
        public IDictionary<String, String> DefaultHeader()
        {
            return new ReadOnlyDictionary<string, string>(this.Configuration.DefaultHeader);
        }

        /// <summary>
        /// Add default header.
        /// </summary>
        /// <param name="key">Header field name.</param>
        /// <param name="value">Header field value.</param>
        /// <returns></returns>
        [Obsolete("AddDefaultHeader is deprecated, please use Configuration.AddDefaultHeader instead.")]
        public void AddDefaultHeader(string key, string value)
        {
            this.Configuration.AddDefaultHeader(key, value);
        }

        /// <summary>
        ///  Deletes a set of process instances asynchronously (batch) based on a historic process instance query.
        /// </summary>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">**Unallowed property**: &#x60;processInstanceQuery&#x60; (optional)</param>
        /// <returns>BatchDto</returns>
        public BatchDto DeleteAsyncHistoricQueryBased (DeleteProcessInstancesDto body = null)
        {
             ApiResponse<BatchDto> localVarResponse = DeleteAsyncHistoricQueryBasedWithHttpInfo(body);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  Deletes a set of process instances asynchronously (batch) based on a historic process instance query.
        /// </summary>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">**Unallowed property**: &#x60;processInstanceQuery&#x60; (optional)</param>
        /// <returns>ApiResponse of BatchDto</returns>
        public ApiResponse< BatchDto > DeleteAsyncHistoricQueryBasedWithHttpInfo (DeleteProcessInstancesDto body = null)
        {

            var localVarPath = "/process-instance/delete-historic-query-based";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteAsyncHistoricQueryBased", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<BatchDto>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (BatchDto) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(BatchDto)));
        }

        /// <summary>
        ///  Deletes a set of process instances asynchronously (batch) based on a historic process instance query.
        /// </summary>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">**Unallowed property**: &#x60;processInstanceQuery&#x60; (optional)</param>
        /// <returns>Task of BatchDto</returns>
        public async System.Threading.Tasks.Task<BatchDto> DeleteAsyncHistoricQueryBasedAsync (DeleteProcessInstancesDto body = null)
        {
             ApiResponse<BatchDto> localVarResponse = await DeleteAsyncHistoricQueryBasedAsyncWithHttpInfo(body);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  Deletes a set of process instances asynchronously (batch) based on a historic process instance query.
        /// </summary>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">**Unallowed property**: &#x60;processInstanceQuery&#x60; (optional)</param>
        /// <returns>Task of ApiResponse (BatchDto)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<BatchDto>> DeleteAsyncHistoricQueryBasedAsyncWithHttpInfo (DeleteProcessInstancesDto body = null)
        {

            var localVarPath = "/process-instance/delete-historic-query-based";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteAsyncHistoricQueryBased", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<BatchDto>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (BatchDto) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(BatchDto)));
        }

        /// <summary>
        ///  Deletes a running process instance by id.
        /// </summary>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to be deleted.</param>
        /// <param name="skipCustomListeners">If set to true, the custom listeners will be skipped. (optional, default to false)</param>
        /// <param name="skipIoMappings">If set to true, the input/output mappings will be skipped. (optional, default to false)</param>
        /// <param name="skipSubprocesses">If set to true, subprocesses related to deleted processes will be skipped. (optional, default to false)</param>
        /// <param name="failIfNotExists">If set to false, the request will still be successful if the process id is not found. (optional, default to true)</param>
        /// <returns></returns>
        public void DeleteProcessInstance (string id, bool? skipCustomListeners = null, bool? skipIoMappings = null, bool? skipSubprocesses = null, bool? failIfNotExists = null)
        {
             DeleteProcessInstanceWithHttpInfo(id, skipCustomListeners, skipIoMappings, skipSubprocesses, failIfNotExists);
        }

        /// <summary>
        ///  Deletes a running process instance by id.
        /// </summary>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to be deleted.</param>
        /// <param name="skipCustomListeners">If set to true, the custom listeners will be skipped. (optional, default to false)</param>
        /// <param name="skipIoMappings">If set to true, the input/output mappings will be skipped. (optional, default to false)</param>
        /// <param name="skipSubprocesses">If set to true, subprocesses related to deleted processes will be skipped. (optional, default to false)</param>
        /// <param name="failIfNotExists">If set to false, the request will still be successful if the process id is not found. (optional, default to true)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> DeleteProcessInstanceWithHttpInfo (string id, bool? skipCustomListeners = null, bool? skipIoMappings = null, bool? skipSubprocesses = null, bool? failIfNotExists = null)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling ProcessInstanceApi->DeleteProcessInstance");

            var localVarPath = "/process-instance/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (skipCustomListeners != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "skipCustomListeners", skipCustomListeners)); // query parameter
            if (skipIoMappings != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "skipIoMappings", skipIoMappings)); // query parameter
            if (skipSubprocesses != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "skipSubprocesses", skipSubprocesses)); // query parameter
            if (failIfNotExists != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "failIfNotExists", failIfNotExists)); // query parameter

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteProcessInstance", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        ///  Deletes a running process instance by id.
        /// </summary>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to be deleted.</param>
        /// <param name="skipCustomListeners">If set to true, the custom listeners will be skipped. (optional, default to false)</param>
        /// <param name="skipIoMappings">If set to true, the input/output mappings will be skipped. (optional, default to false)</param>
        /// <param name="skipSubprocesses">If set to true, subprocesses related to deleted processes will be skipped. (optional, default to false)</param>
        /// <param name="failIfNotExists">If set to false, the request will still be successful if the process id is not found. (optional, default to true)</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task DeleteProcessInstanceAsync (string id, bool? skipCustomListeners = null, bool? skipIoMappings = null, bool? skipSubprocesses = null, bool? failIfNotExists = null)
        {
             await DeleteProcessInstanceAsyncWithHttpInfo(id, skipCustomListeners, skipIoMappings, skipSubprocesses, failIfNotExists);

        }

        /// <summary>
        ///  Deletes a running process instance by id.
        /// </summary>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to be deleted.</param>
        /// <param name="skipCustomListeners">If set to true, the custom listeners will be skipped. (optional, default to false)</param>
        /// <param name="skipIoMappings">If set to true, the input/output mappings will be skipped. (optional, default to false)</param>
        /// <param name="skipSubprocesses">If set to true, subprocesses related to deleted processes will be skipped. (optional, default to false)</param>
        /// <param name="failIfNotExists">If set to false, the request will still be successful if the process id is not found. (optional, default to true)</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> DeleteProcessInstanceAsyncWithHttpInfo (string id, bool? skipCustomListeners = null, bool? skipIoMappings = null, bool? skipSubprocesses = null, bool? failIfNotExists = null)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling ProcessInstanceApi->DeleteProcessInstance");

            var localVarPath = "/process-instance/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (skipCustomListeners != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "skipCustomListeners", skipCustomListeners)); // query parameter
            if (skipIoMappings != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "skipIoMappings", skipIoMappings)); // query parameter
            if (skipSubprocesses != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "skipSubprocesses", skipSubprocesses)); // query parameter
            if (failIfNotExists != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "failIfNotExists", failIfNotExists)); // query parameter

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteProcessInstance", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        ///  Deletes a variable of a process instance by id.
        /// </summary>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to delete the variable from.</param>
        /// <param name="varName">The name of the variable to delete.</param>
        /// <returns></returns>
        public void DeleteProcessInstanceVariable (string id, string varName)
        {
             DeleteProcessInstanceVariableWithHttpInfo(id, varName);
        }

        /// <summary>
        ///  Deletes a variable of a process instance by id.
        /// </summary>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to delete the variable from.</param>
        /// <param name="varName">The name of the variable to delete.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> DeleteProcessInstanceVariableWithHttpInfo (string id, string varName)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling ProcessInstanceApi->DeleteProcessInstanceVariable");
            // verify the required parameter 'varName' is set
            if (varName == null)
                throw new ApiException(400, "Missing required parameter 'varName' when calling ProcessInstanceApi->DeleteProcessInstanceVariable");

            var localVarPath = "/process-instance/{id}/variables/{varName}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (varName != null) localVarPathParams.Add("varName", this.Configuration.ApiClient.ParameterToString(varName)); // path parameter

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteProcessInstanceVariable", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        ///  Deletes a variable of a process instance by id.
        /// </summary>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to delete the variable from.</param>
        /// <param name="varName">The name of the variable to delete.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task DeleteProcessInstanceVariableAsync (string id, string varName)
        {
             await DeleteProcessInstanceVariableAsyncWithHttpInfo(id, varName);

        }

        /// <summary>
        ///  Deletes a variable of a process instance by id.
        /// </summary>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to delete the variable from.</param>
        /// <param name="varName">The name of the variable to delete.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> DeleteProcessInstanceVariableAsyncWithHttpInfo (string id, string varName)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling ProcessInstanceApi->DeleteProcessInstanceVariable");
            // verify the required parameter 'varName' is set
            if (varName == null)
                throw new ApiException(400, "Missing required parameter 'varName' when calling ProcessInstanceApi->DeleteProcessInstanceVariable");

            var localVarPath = "/process-instance/{id}/variables/{varName}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (varName != null) localVarPathParams.Add("varName", this.Configuration.ApiClient.ParameterToString(varName)); // path parameter

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteProcessInstanceVariable", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        ///  Deletes multiple process instances asynchronously (batch).
        /// </summary>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">**Unallowed property**: &#x60;historicProcessInstanceQuery&#x60; (optional)</param>
        /// <returns>BatchDto</returns>
        public BatchDto DeleteProcessInstancesAsyncOperation (DeleteProcessInstancesDto body = null)
        {
             ApiResponse<BatchDto> localVarResponse = DeleteProcessInstancesAsyncOperationWithHttpInfo(body);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  Deletes multiple process instances asynchronously (batch).
        /// </summary>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">**Unallowed property**: &#x60;historicProcessInstanceQuery&#x60; (optional)</param>
        /// <returns>ApiResponse of BatchDto</returns>
        public ApiResponse< BatchDto > DeleteProcessInstancesAsyncOperationWithHttpInfo (DeleteProcessInstancesDto body = null)
        {

            var localVarPath = "/process-instance/delete";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteProcessInstancesAsyncOperation", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<BatchDto>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (BatchDto) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(BatchDto)));
        }

        /// <summary>
        ///  Deletes multiple process instances asynchronously (batch).
        /// </summary>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">**Unallowed property**: &#x60;historicProcessInstanceQuery&#x60; (optional)</param>
        /// <returns>Task of BatchDto</returns>
        public async System.Threading.Tasks.Task<BatchDto> DeleteProcessInstancesAsyncOperationAsync (DeleteProcessInstancesDto body = null)
        {
             ApiResponse<BatchDto> localVarResponse = await DeleteProcessInstancesAsyncOperationAsyncWithHttpInfo(body);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  Deletes multiple process instances asynchronously (batch).
        /// </summary>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">**Unallowed property**: &#x60;historicProcessInstanceQuery&#x60; (optional)</param>
        /// <returns>Task of ApiResponse (BatchDto)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<BatchDto>> DeleteProcessInstancesAsyncOperationAsyncWithHttpInfo (DeleteProcessInstancesDto body = null)
        {

            var localVarPath = "/process-instance/delete";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteProcessInstancesAsyncOperation", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<BatchDto>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (BatchDto) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(BatchDto)));
        }

        /// <summary>
        ///  Retrieves an Activity Instance (Tree) for a given process instance by id.
        /// </summary>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance for which the activity instance should be retrieved.</param>
        /// <returns>ActivityInstanceDto</returns>
        public ActivityInstanceDto GetActivityInstanceTree (string id)
        {
             ApiResponse<ActivityInstanceDto> localVarResponse = GetActivityInstanceTreeWithHttpInfo(id);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  Retrieves an Activity Instance (Tree) for a given process instance by id.
        /// </summary>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance for which the activity instance should be retrieved.</param>
        /// <returns>ApiResponse of ActivityInstanceDto</returns>
        public ApiResponse< ActivityInstanceDto > GetActivityInstanceTreeWithHttpInfo (string id)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling ProcessInstanceApi->GetActivityInstanceTree");

            var localVarPath = "/process-instance/{id}/activity-instances";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetActivityInstanceTree", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<ActivityInstanceDto>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (ActivityInstanceDto) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(ActivityInstanceDto)));
        }

        /// <summary>
        ///  Retrieves an Activity Instance (Tree) for a given process instance by id.
        /// </summary>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance for which the activity instance should be retrieved.</param>
        /// <returns>Task of ActivityInstanceDto</returns>
        public async System.Threading.Tasks.Task<ActivityInstanceDto> GetActivityInstanceTreeAsync (string id)
        {
             ApiResponse<ActivityInstanceDto> localVarResponse = await GetActivityInstanceTreeAsyncWithHttpInfo(id);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  Retrieves an Activity Instance (Tree) for a given process instance by id.
        /// </summary>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance for which the activity instance should be retrieved.</param>
        /// <returns>Task of ApiResponse (ActivityInstanceDto)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<ActivityInstanceDto>> GetActivityInstanceTreeAsyncWithHttpInfo (string id)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling ProcessInstanceApi->GetActivityInstanceTree");

            var localVarPath = "/process-instance/{id}/activity-instances";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetActivityInstanceTree", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<ActivityInstanceDto>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (ActivityInstanceDto) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(ActivityInstanceDto)));
        }

        /// <summary>
        ///  Retrieves a variable of a given process instance by id.
        /// </summary>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to retrieve the variable for.</param>
        /// <param name="varName">The name of the variable to retrieve.</param>
        /// <param name="deserializeValue">Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine. (optional, default to true)</param>
        /// <returns>VariableValueDto</returns>
        public VariableValueDto GetProcessInstanceVariable (string id, string varName, bool? deserializeValue = null)
        {
             ApiResponse<VariableValueDto> localVarResponse = GetProcessInstanceVariableWithHttpInfo(id, varName, deserializeValue);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  Retrieves a variable of a given process instance by id.
        /// </summary>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to retrieve the variable for.</param>
        /// <param name="varName">The name of the variable to retrieve.</param>
        /// <param name="deserializeValue">Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine. (optional, default to true)</param>
        /// <returns>ApiResponse of VariableValueDto</returns>
        public ApiResponse< VariableValueDto > GetProcessInstanceVariableWithHttpInfo (string id, string varName, bool? deserializeValue = null)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling ProcessInstanceApi->GetProcessInstanceVariable");
            // verify the required parameter 'varName' is set
            if (varName == null)
                throw new ApiException(400, "Missing required parameter 'varName' when calling ProcessInstanceApi->GetProcessInstanceVariable");

            var localVarPath = "/process-instance/{id}/variables/{varName}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (varName != null) localVarPathParams.Add("varName", this.Configuration.ApiClient.ParameterToString(varName)); // path parameter
            if (deserializeValue != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "deserializeValue", deserializeValue)); // query parameter

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetProcessInstanceVariable", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<VariableValueDto>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (VariableValueDto) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(VariableValueDto)));
        }

        /// <summary>
        ///  Retrieves a variable of a given process instance by id.
        /// </summary>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to retrieve the variable for.</param>
        /// <param name="varName">The name of the variable to retrieve.</param>
        /// <param name="deserializeValue">Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine. (optional, default to true)</param>
        /// <returns>Task of VariableValueDto</returns>
        public async System.Threading.Tasks.Task<VariableValueDto> GetProcessInstanceVariableAsync (string id, string varName, bool? deserializeValue = null)
        {
             ApiResponse<VariableValueDto> localVarResponse = await GetProcessInstanceVariableAsyncWithHttpInfo(id, varName, deserializeValue);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  Retrieves a variable of a given process instance by id.
        /// </summary>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to retrieve the variable for.</param>
        /// <param name="varName">The name of the variable to retrieve.</param>
        /// <param name="deserializeValue">Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine. (optional, default to true)</param>
        /// <returns>Task of ApiResponse (VariableValueDto)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<VariableValueDto>> GetProcessInstanceVariableAsyncWithHttpInfo (string id, string varName, bool? deserializeValue = null)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling ProcessInstanceApi->GetProcessInstanceVariable");
            // verify the required parameter 'varName' is set
            if (varName == null)
                throw new ApiException(400, "Missing required parameter 'varName' when calling ProcessInstanceApi->GetProcessInstanceVariable");

            var localVarPath = "/process-instance/{id}/variables/{varName}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (varName != null) localVarPathParams.Add("varName", this.Configuration.ApiClient.ParameterToString(varName)); // path parameter
            if (deserializeValue != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "deserializeValue", deserializeValue)); // query parameter

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetProcessInstanceVariable", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<VariableValueDto>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (VariableValueDto) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(VariableValueDto)));
        }

        /// <summary>
        ///  Retrieves the content of a Process Variable by the Process Instance id and the Process Variable name. Applicable for byte array or file Process Variables.
        /// </summary>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to retrieve the variable for.</param>
        /// <param name="varName">The name of the variable to retrieve.</param>
        /// <returns>byte[]</returns>
        public byte[] GetProcessInstanceVariableBinary (string id, string varName)
        {
             ApiResponse<byte[]> localVarResponse = GetProcessInstanceVariableBinaryWithHttpInfo(id, varName);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  Retrieves the content of a Process Variable by the Process Instance id and the Process Variable name. Applicable for byte array or file Process Variables.
        /// </summary>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to retrieve the variable for.</param>
        /// <param name="varName">The name of the variable to retrieve.</param>
        /// <returns>ApiResponse of byte[]</returns>
        public ApiResponse< byte[] > GetProcessInstanceVariableBinaryWithHttpInfo (string id, string varName)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling ProcessInstanceApi->GetProcessInstanceVariableBinary");
            // verify the required parameter 'varName' is set
            if (varName == null)
                throw new ApiException(400, "Missing required parameter 'varName' when calling ProcessInstanceApi->GetProcessInstanceVariableBinary");

            var localVarPath = "/process-instance/{id}/variables/{varName}/data";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/octet-stream",
                "text/plain",
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (varName != null) localVarPathParams.Add("varName", this.Configuration.ApiClient.ParameterToString(varName)); // path parameter

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetProcessInstanceVariableBinary", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<byte[]>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (byte[]) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(byte[])));
        }

        /// <summary>
        ///  Retrieves the content of a Process Variable by the Process Instance id and the Process Variable name. Applicable for byte array or file Process Variables.
        /// </summary>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to retrieve the variable for.</param>
        /// <param name="varName">The name of the variable to retrieve.</param>
        /// <returns>Task of byte[]</returns>
        public async System.Threading.Tasks.Task<byte[]> GetProcessInstanceVariableBinaryAsync (string id, string varName)
        {
             ApiResponse<byte[]> localVarResponse = await GetProcessInstanceVariableBinaryAsyncWithHttpInfo(id, varName);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  Retrieves the content of a Process Variable by the Process Instance id and the Process Variable name. Applicable for byte array or file Process Variables.
        /// </summary>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to retrieve the variable for.</param>
        /// <param name="varName">The name of the variable to retrieve.</param>
        /// <returns>Task of ApiResponse (byte[])</returns>
        public async System.Threading.Tasks.Task<ApiResponse<byte[]>> GetProcessInstanceVariableBinaryAsyncWithHttpInfo (string id, string varName)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling ProcessInstanceApi->GetProcessInstanceVariableBinary");
            // verify the required parameter 'varName' is set
            if (varName == null)
                throw new ApiException(400, "Missing required parameter 'varName' when calling ProcessInstanceApi->GetProcessInstanceVariableBinary");

            var localVarPath = "/process-instance/{id}/variables/{varName}/data";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/octet-stream",
                "text/plain",
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (varName != null) localVarPathParams.Add("varName", this.Configuration.ApiClient.ParameterToString(varName)); // path parameter

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetProcessInstanceVariableBinary", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<byte[]>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (byte[]) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(byte[])));
        }

        /// <summary>
        ///  Retrieves all variables of a given process instance by id.
        /// </summary>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to retrieve the variables from.</param>
        /// <param name="deserializeValue">Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine. (optional, default to true)</param>
        /// <returns>Dictionary&lt;string, VariableValueDto&gt;</returns>
        public Dictionary<string, VariableValueDto> GetProcessInstanceVariables (string id, bool? deserializeValue = null)
        {
             ApiResponse<Dictionary<string, VariableValueDto>> localVarResponse = GetProcessInstanceVariablesWithHttpInfo(id, deserializeValue);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  Retrieves all variables of a given process instance by id.
        /// </summary>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to retrieve the variables from.</param>
        /// <param name="deserializeValue">Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine. (optional, default to true)</param>
        /// <returns>ApiResponse of Dictionary&lt;string, VariableValueDto&gt;</returns>
        public ApiResponse< Dictionary<string, VariableValueDto> > GetProcessInstanceVariablesWithHttpInfo (string id, bool? deserializeValue = null)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling ProcessInstanceApi->GetProcessInstanceVariables");

            var localVarPath = "/process-instance/{id}/variables";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (deserializeValue != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "deserializeValue", deserializeValue)); // query parameter

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetProcessInstanceVariables", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Dictionary<string, VariableValueDto>>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (Dictionary<string, VariableValueDto>) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(Dictionary<string, VariableValueDto>)));
        }

        /// <summary>
        ///  Retrieves all variables of a given process instance by id.
        /// </summary>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to retrieve the variables from.</param>
        /// <param name="deserializeValue">Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine. (optional, default to true)</param>
        /// <returns>Task of Dictionary&lt;string, VariableValueDto&gt;</returns>
        public async System.Threading.Tasks.Task<Dictionary<string, VariableValueDto>> GetProcessInstanceVariablesAsync (string id, bool? deserializeValue = null)
        {
             ApiResponse<Dictionary<string, VariableValueDto>> localVarResponse = await GetProcessInstanceVariablesAsyncWithHttpInfo(id, deserializeValue);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  Retrieves all variables of a given process instance by id.
        /// </summary>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to retrieve the variables from.</param>
        /// <param name="deserializeValue">Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine. (optional, default to true)</param>
        /// <returns>Task of ApiResponse (Dictionary&lt;string, VariableValueDto&gt;)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Dictionary<string, VariableValueDto>>> GetProcessInstanceVariablesAsyncWithHttpInfo (string id, bool? deserializeValue = null)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling ProcessInstanceApi->GetProcessInstanceVariables");

            var localVarPath = "/process-instance/{id}/variables";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (deserializeValue != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "deserializeValue", deserializeValue)); // query parameter

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetProcessInstanceVariables", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Dictionary<string, VariableValueDto>>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (Dictionary<string, VariableValueDto>) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(Dictionary<string, VariableValueDto>)));
        }

        /// <summary>
        ///  Queries for process instances that fulfill given parameters. Parameters may be static as well as dynamic runtime properties of process instances. The size of the result set can be retrieved by using the Get Instance Count method.
        /// </summary>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sortBy">Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter. (optional)</param>
        /// <param name="sortOrder">Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter. (optional)</param>
        /// <param name="firstResult">Pagination of results. Specifies the index of the first result to return. (optional)</param>
        /// <param name="maxResults">Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)</param>
        /// <param name="processInstanceIds">Filter by a comma-separated list of process instance ids. (optional)</param>
        /// <param name="businessKey">Filter by process instance business key. (optional)</param>
        /// <param name="businessKeyLike">Filter by process instance business key that the parameter is a substring of. (optional)</param>
        /// <param name="caseInstanceId">Filter by case instance id. (optional)</param>
        /// <param name="processDefinitionId">Filter by the deployment the id belongs to. (optional)</param>
        /// <param name="processDefinitionKey">Filter by the key of the process definition the instances run on. (optional)</param>
        /// <param name="processDefinitionKeyIn">Filter by a comma-separated list of process definition keys. A process instance must have one of the given process definition keys. (optional)</param>
        /// <param name="processDefinitionKeyNotIn">Exclude instances by a comma-separated list of process definition keys. A process instance must not have one of the given process definition keys. (optional)</param>
        /// <param name="deploymentId">Filter by the deployment the id belongs to. (optional)</param>
        /// <param name="superProcessInstance">Restrict query to all process instances that are sub process instances of the given process instance. Takes a process instance id. (optional)</param>
        /// <param name="subProcessInstance">Restrict query to all process instances that have the given process instance as a sub process instance. Takes a process instance id. (optional)</param>
        /// <param name="superCaseInstance">Restrict query to all process instances that are sub process instances of the given case instance. Takes a case instance id. (optional)</param>
        /// <param name="subCaseInstance">Restrict query to all process instances that have the given case instance as a sub case instance. Takes a case instance id. (optional)</param>
        /// <param name="active">Only include active process instances. Value may only be true, as false is the default behavior. (optional, default to false)</param>
        /// <param name="suspended">Only include suspended process instances. Value may only be true, as false is the default behavior. (optional, default to false)</param>
        /// <param name="withIncident">Filter by presence of incidents. Selects only process instances that have an incident. (optional, default to false)</param>
        /// <param name="incidentId">Filter by the incident id. (optional)</param>
        /// <param name="incidentType">Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)</param>
        /// <param name="incidentMessage">Filter by the incident message. Exact match. (optional)</param>
        /// <param name="incidentMessageLike">Filter by the incident message that the parameter is a substring of. (optional)</param>
        /// <param name="tenantIdIn">Filter by a comma-separated list of tenant ids. A process instance must have one of the given tenant ids. (optional)</param>
        /// <param name="withoutTenantId">Only include process instances which belong to no tenant. (optional, default to false)</param>
        /// <param name="processDefinitionWithoutTenantId">Only include process instances which process definition has no tenant id. (optional, default to false)</param>
        /// <param name="activityIdIn">Filter by a comma-separated list of activity ids. A process instance must currently wait in a leaf activity with one of the given activity ids. (optional)</param>
        /// <param name="rootProcessInstances">Restrict the query to all process instances that are top level process instances. (optional, default to false)</param>
        /// <param name="leafProcessInstances">Restrict the query to all process instances that are leaf instances. (i.e. don&#x27;t have any sub instances). (optional, default to false)</param>
        /// <param name="variables">Only include process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)</param>
        /// <param name="variableNamesIgnoreCase">Match all variable names in this query case-insensitively. If set to true variableName and variablename are treated as equal. (optional, default to false)</param>
        /// <param name="variableValuesIgnoreCase">Match all variable values in this query case-insensitively. If set to true variableValue and variablevalue are treated as equal. (optional, default to false)</param>
        /// <returns>List&lt;ProcessInstanceDto&gt;</returns>
        public List<ProcessInstanceDto> GetProcessInstances (string sortBy = null, string sortOrder = null, int? firstResult = null, int? maxResults = null, string processInstanceIds = null, string businessKey = null, string businessKeyLike = null, string caseInstanceId = null, string processDefinitionId = null, string processDefinitionKey = null, string processDefinitionKeyIn = null, string processDefinitionKeyNotIn = null, string deploymentId = null, string superProcessInstance = null, string subProcessInstance = null, string superCaseInstance = null, string subCaseInstance = null, bool? active = null, bool? suspended = null, bool? withIncident = null, string incidentId = null, string incidentType = null, string incidentMessage = null, string incidentMessageLike = null, string tenantIdIn = null, bool? withoutTenantId = null, bool? processDefinitionWithoutTenantId = null, string activityIdIn = null, bool? rootProcessInstances = null, bool? leafProcessInstances = null, string variables = null, bool? variableNamesIgnoreCase = null, bool? variableValuesIgnoreCase = null)
        {
             ApiResponse<List<ProcessInstanceDto>> localVarResponse = GetProcessInstancesWithHttpInfo(sortBy, sortOrder, firstResult, maxResults, processInstanceIds, businessKey, businessKeyLike, caseInstanceId, processDefinitionId, processDefinitionKey, processDefinitionKeyIn, processDefinitionKeyNotIn, deploymentId, superProcessInstance, subProcessInstance, superCaseInstance, subCaseInstance, active, suspended, withIncident, incidentId, incidentType, incidentMessage, incidentMessageLike, tenantIdIn, withoutTenantId, processDefinitionWithoutTenantId, activityIdIn, rootProcessInstances, leafProcessInstances, variables, variableNamesIgnoreCase, variableValuesIgnoreCase);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  Queries for process instances that fulfill given parameters. Parameters may be static as well as dynamic runtime properties of process instances. The size of the result set can be retrieved by using the Get Instance Count method.
        /// </summary>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sortBy">Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter. (optional)</param>
        /// <param name="sortOrder">Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter. (optional)</param>
        /// <param name="firstResult">Pagination of results. Specifies the index of the first result to return. (optional)</param>
        /// <param name="maxResults">Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)</param>
        /// <param name="processInstanceIds">Filter by a comma-separated list of process instance ids. (optional)</param>
        /// <param name="businessKey">Filter by process instance business key. (optional)</param>
        /// <param name="businessKeyLike">Filter by process instance business key that the parameter is a substring of. (optional)</param>
        /// <param name="caseInstanceId">Filter by case instance id. (optional)</param>
        /// <param name="processDefinitionId">Filter by the deployment the id belongs to. (optional)</param>
        /// <param name="processDefinitionKey">Filter by the key of the process definition the instances run on. (optional)</param>
        /// <param name="processDefinitionKeyIn">Filter by a comma-separated list of process definition keys. A process instance must have one of the given process definition keys. (optional)</param>
        /// <param name="processDefinitionKeyNotIn">Exclude instances by a comma-separated list of process definition keys. A process instance must not have one of the given process definition keys. (optional)</param>
        /// <param name="deploymentId">Filter by the deployment the id belongs to. (optional)</param>
        /// <param name="superProcessInstance">Restrict query to all process instances that are sub process instances of the given process instance. Takes a process instance id. (optional)</param>
        /// <param name="subProcessInstance">Restrict query to all process instances that have the given process instance as a sub process instance. Takes a process instance id. (optional)</param>
        /// <param name="superCaseInstance">Restrict query to all process instances that are sub process instances of the given case instance. Takes a case instance id. (optional)</param>
        /// <param name="subCaseInstance">Restrict query to all process instances that have the given case instance as a sub case instance. Takes a case instance id. (optional)</param>
        /// <param name="active">Only include active process instances. Value may only be true, as false is the default behavior. (optional, default to false)</param>
        /// <param name="suspended">Only include suspended process instances. Value may only be true, as false is the default behavior. (optional, default to false)</param>
        /// <param name="withIncident">Filter by presence of incidents. Selects only process instances that have an incident. (optional, default to false)</param>
        /// <param name="incidentId">Filter by the incident id. (optional)</param>
        /// <param name="incidentType">Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)</param>
        /// <param name="incidentMessage">Filter by the incident message. Exact match. (optional)</param>
        /// <param name="incidentMessageLike">Filter by the incident message that the parameter is a substring of. (optional)</param>
        /// <param name="tenantIdIn">Filter by a comma-separated list of tenant ids. A process instance must have one of the given tenant ids. (optional)</param>
        /// <param name="withoutTenantId">Only include process instances which belong to no tenant. (optional, default to false)</param>
        /// <param name="processDefinitionWithoutTenantId">Only include process instances which process definition has no tenant id. (optional, default to false)</param>
        /// <param name="activityIdIn">Filter by a comma-separated list of activity ids. A process instance must currently wait in a leaf activity with one of the given activity ids. (optional)</param>
        /// <param name="rootProcessInstances">Restrict the query to all process instances that are top level process instances. (optional, default to false)</param>
        /// <param name="leafProcessInstances">Restrict the query to all process instances that are leaf instances. (i.e. don&#x27;t have any sub instances). (optional, default to false)</param>
        /// <param name="variables">Only include process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)</param>
        /// <param name="variableNamesIgnoreCase">Match all variable names in this query case-insensitively. If set to true variableName and variablename are treated as equal. (optional, default to false)</param>
        /// <param name="variableValuesIgnoreCase">Match all variable values in this query case-insensitively. If set to true variableValue and variablevalue are treated as equal. (optional, default to false)</param>
        /// <returns>ApiResponse of List&lt;ProcessInstanceDto&gt;</returns>
        public ApiResponse< List<ProcessInstanceDto> > GetProcessInstancesWithHttpInfo (string sortBy = null, string sortOrder = null, int? firstResult = null, int? maxResults = null, string processInstanceIds = null, string businessKey = null, string businessKeyLike = null, string caseInstanceId = null, string processDefinitionId = null, string processDefinitionKey = null, string processDefinitionKeyIn = null, string processDefinitionKeyNotIn = null, string deploymentId = null, string superProcessInstance = null, string subProcessInstance = null, string superCaseInstance = null, string subCaseInstance = null, bool? active = null, bool? suspended = null, bool? withIncident = null, string incidentId = null, string incidentType = null, string incidentMessage = null, string incidentMessageLike = null, string tenantIdIn = null, bool? withoutTenantId = null, bool? processDefinitionWithoutTenantId = null, string activityIdIn = null, bool? rootProcessInstances = null, bool? leafProcessInstances = null, string variables = null, bool? variableNamesIgnoreCase = null, bool? variableValuesIgnoreCase = null)
        {

            var localVarPath = "/process-instance";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (sortBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "sortBy", sortBy)); // query parameter
            if (sortOrder != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "sortOrder", sortOrder)); // query parameter
            if (firstResult != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "firstResult", firstResult)); // query parameter
            if (maxResults != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "maxResults", maxResults)); // query parameter
            if (processInstanceIds != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "processInstanceIds", processInstanceIds)); // query parameter
            if (businessKey != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "businessKey", businessKey)); // query parameter
            if (businessKeyLike != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "businessKeyLike", businessKeyLike)); // query parameter
            if (caseInstanceId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "caseInstanceId", caseInstanceId)); // query parameter
            if (processDefinitionId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "processDefinitionId", processDefinitionId)); // query parameter
            if (processDefinitionKey != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "processDefinitionKey", processDefinitionKey)); // query parameter
            if (processDefinitionKeyIn != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "processDefinitionKeyIn", processDefinitionKeyIn)); // query parameter
            if (processDefinitionKeyNotIn != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "processDefinitionKeyNotIn", processDefinitionKeyNotIn)); // query parameter
            if (deploymentId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "deploymentId", deploymentId)); // query parameter
            if (superProcessInstance != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "superProcessInstance", superProcessInstance)); // query parameter
            if (subProcessInstance != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "subProcessInstance", subProcessInstance)); // query parameter
            if (superCaseInstance != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "superCaseInstance", superCaseInstance)); // query parameter
            if (subCaseInstance != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "subCaseInstance", subCaseInstance)); // query parameter
            if (active != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "active", active)); // query parameter
            if (suspended != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "suspended", suspended)); // query parameter
            if (withIncident != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "withIncident", withIncident)); // query parameter
            if (incidentId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "incidentId", incidentId)); // query parameter
            if (incidentType != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "incidentType", incidentType)); // query parameter
            if (incidentMessage != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "incidentMessage", incidentMessage)); // query parameter
            if (incidentMessageLike != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "incidentMessageLike", incidentMessageLike)); // query parameter
            if (tenantIdIn != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "tenantIdIn", tenantIdIn)); // query parameter
            if (withoutTenantId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "withoutTenantId", withoutTenantId)); // query parameter
            if (processDefinitionWithoutTenantId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "processDefinitionWithoutTenantId", processDefinitionWithoutTenantId)); // query parameter
            if (activityIdIn != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "activityIdIn", activityIdIn)); // query parameter
            if (rootProcessInstances != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "rootProcessInstances", rootProcessInstances)); // query parameter
            if (leafProcessInstances != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "leafProcessInstances", leafProcessInstances)); // query parameter
            if (variables != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "variables", variables)); // query parameter
            if (variableNamesIgnoreCase != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "variableNamesIgnoreCase", variableNamesIgnoreCase)); // query parameter
            if (variableValuesIgnoreCase != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "variableValuesIgnoreCase", variableValuesIgnoreCase)); // query parameter

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetProcessInstances", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<List<ProcessInstanceDto>>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (List<ProcessInstanceDto>) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(List<ProcessInstanceDto>)));
        }

        /// <summary>
        ///  Queries for process instances that fulfill given parameters. Parameters may be static as well as dynamic runtime properties of process instances. The size of the result set can be retrieved by using the Get Instance Count method.
        /// </summary>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sortBy">Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter. (optional)</param>
        /// <param name="sortOrder">Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter. (optional)</param>
        /// <param name="firstResult">Pagination of results. Specifies the index of the first result to return. (optional)</param>
        /// <param name="maxResults">Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)</param>
        /// <param name="processInstanceIds">Filter by a comma-separated list of process instance ids. (optional)</param>
        /// <param name="businessKey">Filter by process instance business key. (optional)</param>
        /// <param name="businessKeyLike">Filter by process instance business key that the parameter is a substring of. (optional)</param>
        /// <param name="caseInstanceId">Filter by case instance id. (optional)</param>
        /// <param name="processDefinitionId">Filter by the deployment the id belongs to. (optional)</param>
        /// <param name="processDefinitionKey">Filter by the key of the process definition the instances run on. (optional)</param>
        /// <param name="processDefinitionKeyIn">Filter by a comma-separated list of process definition keys. A process instance must have one of the given process definition keys. (optional)</param>
        /// <param name="processDefinitionKeyNotIn">Exclude instances by a comma-separated list of process definition keys. A process instance must not have one of the given process definition keys. (optional)</param>
        /// <param name="deploymentId">Filter by the deployment the id belongs to. (optional)</param>
        /// <param name="superProcessInstance">Restrict query to all process instances that are sub process instances of the given process instance. Takes a process instance id. (optional)</param>
        /// <param name="subProcessInstance">Restrict query to all process instances that have the given process instance as a sub process instance. Takes a process instance id. (optional)</param>
        /// <param name="superCaseInstance">Restrict query to all process instances that are sub process instances of the given case instance. Takes a case instance id. (optional)</param>
        /// <param name="subCaseInstance">Restrict query to all process instances that have the given case instance as a sub case instance. Takes a case instance id. (optional)</param>
        /// <param name="active">Only include active process instances. Value may only be true, as false is the default behavior. (optional, default to false)</param>
        /// <param name="suspended">Only include suspended process instances. Value may only be true, as false is the default behavior. (optional, default to false)</param>
        /// <param name="withIncident">Filter by presence of incidents. Selects only process instances that have an incident. (optional, default to false)</param>
        /// <param name="incidentId">Filter by the incident id. (optional)</param>
        /// <param name="incidentType">Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)</param>
        /// <param name="incidentMessage">Filter by the incident message. Exact match. (optional)</param>
        /// <param name="incidentMessageLike">Filter by the incident message that the parameter is a substring of. (optional)</param>
        /// <param name="tenantIdIn">Filter by a comma-separated list of tenant ids. A process instance must have one of the given tenant ids. (optional)</param>
        /// <param name="withoutTenantId">Only include process instances which belong to no tenant. (optional, default to false)</param>
        /// <param name="processDefinitionWithoutTenantId">Only include process instances which process definition has no tenant id. (optional, default to false)</param>
        /// <param name="activityIdIn">Filter by a comma-separated list of activity ids. A process instance must currently wait in a leaf activity with one of the given activity ids. (optional)</param>
        /// <param name="rootProcessInstances">Restrict the query to all process instances that are top level process instances. (optional, default to false)</param>
        /// <param name="leafProcessInstances">Restrict the query to all process instances that are leaf instances. (i.e. don&#x27;t have any sub instances). (optional, default to false)</param>
        /// <param name="variables">Only include process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)</param>
        /// <param name="variableNamesIgnoreCase">Match all variable names in this query case-insensitively. If set to true variableName and variablename are treated as equal. (optional, default to false)</param>
        /// <param name="variableValuesIgnoreCase">Match all variable values in this query case-insensitively. If set to true variableValue and variablevalue are treated as equal. (optional, default to false)</param>
        /// <returns>Task of List&lt;ProcessInstanceDto&gt;</returns>
        public async System.Threading.Tasks.Task<List<ProcessInstanceDto>> GetProcessInstancesAsync (string sortBy = null, string sortOrder = null, int? firstResult = null, int? maxResults = null, string processInstanceIds = null, string businessKey = null, string businessKeyLike = null, string caseInstanceId = null, string processDefinitionId = null, string processDefinitionKey = null, string processDefinitionKeyIn = null, string processDefinitionKeyNotIn = null, string deploymentId = null, string superProcessInstance = null, string subProcessInstance = null, string superCaseInstance = null, string subCaseInstance = null, bool? active = null, bool? suspended = null, bool? withIncident = null, string incidentId = null, string incidentType = null, string incidentMessage = null, string incidentMessageLike = null, string tenantIdIn = null, bool? withoutTenantId = null, bool? processDefinitionWithoutTenantId = null, string activityIdIn = null, bool? rootProcessInstances = null, bool? leafProcessInstances = null, string variables = null, bool? variableNamesIgnoreCase = null, bool? variableValuesIgnoreCase = null)
        {
             ApiResponse<List<ProcessInstanceDto>> localVarResponse = await GetProcessInstancesAsyncWithHttpInfo(sortBy, sortOrder, firstResult, maxResults, processInstanceIds, businessKey, businessKeyLike, caseInstanceId, processDefinitionId, processDefinitionKey, processDefinitionKeyIn, processDefinitionKeyNotIn, deploymentId, superProcessInstance, subProcessInstance, superCaseInstance, subCaseInstance, active, suspended, withIncident, incidentId, incidentType, incidentMessage, incidentMessageLike, tenantIdIn, withoutTenantId, processDefinitionWithoutTenantId, activityIdIn, rootProcessInstances, leafProcessInstances, variables, variableNamesIgnoreCase, variableValuesIgnoreCase);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  Queries for process instances that fulfill given parameters. Parameters may be static as well as dynamic runtime properties of process instances. The size of the result set can be retrieved by using the Get Instance Count method.
        /// </summary>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sortBy">Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter. (optional)</param>
        /// <param name="sortOrder">Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter. (optional)</param>
        /// <param name="firstResult">Pagination of results. Specifies the index of the first result to return. (optional)</param>
        /// <param name="maxResults">Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)</param>
        /// <param name="processInstanceIds">Filter by a comma-separated list of process instance ids. (optional)</param>
        /// <param name="businessKey">Filter by process instance business key. (optional)</param>
        /// <param name="businessKeyLike">Filter by process instance business key that the parameter is a substring of. (optional)</param>
        /// <param name="caseInstanceId">Filter by case instance id. (optional)</param>
        /// <param name="processDefinitionId">Filter by the deployment the id belongs to. (optional)</param>
        /// <param name="processDefinitionKey">Filter by the key of the process definition the instances run on. (optional)</param>
        /// <param name="processDefinitionKeyIn">Filter by a comma-separated list of process definition keys. A process instance must have one of the given process definition keys. (optional)</param>
        /// <param name="processDefinitionKeyNotIn">Exclude instances by a comma-separated list of process definition keys. A process instance must not have one of the given process definition keys. (optional)</param>
        /// <param name="deploymentId">Filter by the deployment the id belongs to. (optional)</param>
        /// <param name="superProcessInstance">Restrict query to all process instances that are sub process instances of the given process instance. Takes a process instance id. (optional)</param>
        /// <param name="subProcessInstance">Restrict query to all process instances that have the given process instance as a sub process instance. Takes a process instance id. (optional)</param>
        /// <param name="superCaseInstance">Restrict query to all process instances that are sub process instances of the given case instance. Takes a case instance id. (optional)</param>
        /// <param name="subCaseInstance">Restrict query to all process instances that have the given case instance as a sub case instance. Takes a case instance id. (optional)</param>
        /// <param name="active">Only include active process instances. Value may only be true, as false is the default behavior. (optional, default to false)</param>
        /// <param name="suspended">Only include suspended process instances. Value may only be true, as false is the default behavior. (optional, default to false)</param>
        /// <param name="withIncident">Filter by presence of incidents. Selects only process instances that have an incident. (optional, default to false)</param>
        /// <param name="incidentId">Filter by the incident id. (optional)</param>
        /// <param name="incidentType">Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)</param>
        /// <param name="incidentMessage">Filter by the incident message. Exact match. (optional)</param>
        /// <param name="incidentMessageLike">Filter by the incident message that the parameter is a substring of. (optional)</param>
        /// <param name="tenantIdIn">Filter by a comma-separated list of tenant ids. A process instance must have one of the given tenant ids. (optional)</param>
        /// <param name="withoutTenantId">Only include process instances which belong to no tenant. (optional, default to false)</param>
        /// <param name="processDefinitionWithoutTenantId">Only include process instances which process definition has no tenant id. (optional, default to false)</param>
        /// <param name="activityIdIn">Filter by a comma-separated list of activity ids. A process instance must currently wait in a leaf activity with one of the given activity ids. (optional)</param>
        /// <param name="rootProcessInstances">Restrict the query to all process instances that are top level process instances. (optional, default to false)</param>
        /// <param name="leafProcessInstances">Restrict the query to all process instances that are leaf instances. (i.e. don&#x27;t have any sub instances). (optional, default to false)</param>
        /// <param name="variables">Only include process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)</param>
        /// <param name="variableNamesIgnoreCase">Match all variable names in this query case-insensitively. If set to true variableName and variablename are treated as equal. (optional, default to false)</param>
        /// <param name="variableValuesIgnoreCase">Match all variable values in this query case-insensitively. If set to true variableValue and variablevalue are treated as equal. (optional, default to false)</param>
        /// <returns>Task of ApiResponse (List&lt;ProcessInstanceDto&gt;)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<List<ProcessInstanceDto>>> GetProcessInstancesAsyncWithHttpInfo (string sortBy = null, string sortOrder = null, int? firstResult = null, int? maxResults = null, string processInstanceIds = null, string businessKey = null, string businessKeyLike = null, string caseInstanceId = null, string processDefinitionId = null, string processDefinitionKey = null, string processDefinitionKeyIn = null, string processDefinitionKeyNotIn = null, string deploymentId = null, string superProcessInstance = null, string subProcessInstance = null, string superCaseInstance = null, string subCaseInstance = null, bool? active = null, bool? suspended = null, bool? withIncident = null, string incidentId = null, string incidentType = null, string incidentMessage = null, string incidentMessageLike = null, string tenantIdIn = null, bool? withoutTenantId = null, bool? processDefinitionWithoutTenantId = null, string activityIdIn = null, bool? rootProcessInstances = null, bool? leafProcessInstances = null, string variables = null, bool? variableNamesIgnoreCase = null, bool? variableValuesIgnoreCase = null)
        {

            var localVarPath = "/process-instance";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (sortBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "sortBy", sortBy)); // query parameter
            if (sortOrder != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "sortOrder", sortOrder)); // query parameter
            if (firstResult != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "firstResult", firstResult)); // query parameter
            if (maxResults != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "maxResults", maxResults)); // query parameter
            if (processInstanceIds != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "processInstanceIds", processInstanceIds)); // query parameter
            if (businessKey != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "businessKey", businessKey)); // query parameter
            if (businessKeyLike != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "businessKeyLike", businessKeyLike)); // query parameter
            if (caseInstanceId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "caseInstanceId", caseInstanceId)); // query parameter
            if (processDefinitionId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "processDefinitionId", processDefinitionId)); // query parameter
            if (processDefinitionKey != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "processDefinitionKey", processDefinitionKey)); // query parameter
            if (processDefinitionKeyIn != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "processDefinitionKeyIn", processDefinitionKeyIn)); // query parameter
            if (processDefinitionKeyNotIn != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "processDefinitionKeyNotIn", processDefinitionKeyNotIn)); // query parameter
            if (deploymentId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "deploymentId", deploymentId)); // query parameter
            if (superProcessInstance != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "superProcessInstance", superProcessInstance)); // query parameter
            if (subProcessInstance != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "subProcessInstance", subProcessInstance)); // query parameter
            if (superCaseInstance != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "superCaseInstance", superCaseInstance)); // query parameter
            if (subCaseInstance != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "subCaseInstance", subCaseInstance)); // query parameter
            if (active != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "active", active)); // query parameter
            if (suspended != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "suspended", suspended)); // query parameter
            if (withIncident != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "withIncident", withIncident)); // query parameter
            if (incidentId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "incidentId", incidentId)); // query parameter
            if (incidentType != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "incidentType", incidentType)); // query parameter
            if (incidentMessage != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "incidentMessage", incidentMessage)); // query parameter
            if (incidentMessageLike != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "incidentMessageLike", incidentMessageLike)); // query parameter
            if (tenantIdIn != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "tenantIdIn", tenantIdIn)); // query parameter
            if (withoutTenantId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "withoutTenantId", withoutTenantId)); // query parameter
            if (processDefinitionWithoutTenantId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "processDefinitionWithoutTenantId", processDefinitionWithoutTenantId)); // query parameter
            if (activityIdIn != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "activityIdIn", activityIdIn)); // query parameter
            if (rootProcessInstances != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "rootProcessInstances", rootProcessInstances)); // query parameter
            if (leafProcessInstances != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "leafProcessInstances", leafProcessInstances)); // query parameter
            if (variables != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "variables", variables)); // query parameter
            if (variableNamesIgnoreCase != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "variableNamesIgnoreCase", variableNamesIgnoreCase)); // query parameter
            if (variableValuesIgnoreCase != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "variableValuesIgnoreCase", variableValuesIgnoreCase)); // query parameter

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetProcessInstances", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<List<ProcessInstanceDto>>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (List<ProcessInstanceDto>) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(List<ProcessInstanceDto>)));
        }

        /// <summary>
        ///  Queries for the number of process instances that fulfill given parameters.
        /// </summary>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="processInstanceIds">Filter by a comma-separated list of process instance ids. (optional)</param>
        /// <param name="businessKey">Filter by process instance business key. (optional)</param>
        /// <param name="businessKeyLike">Filter by process instance business key that the parameter is a substring of. (optional)</param>
        /// <param name="caseInstanceId">Filter by case instance id. (optional)</param>
        /// <param name="processDefinitionId">Filter by the deployment the id belongs to. (optional)</param>
        /// <param name="processDefinitionKey">Filter by the key of the process definition the instances run on. (optional)</param>
        /// <param name="processDefinitionKeyIn">Filter by a comma-separated list of process definition keys. A process instance must have one of the given process definition keys. (optional)</param>
        /// <param name="processDefinitionKeyNotIn">Exclude instances by a comma-separated list of process definition keys. A process instance must not have one of the given process definition keys. (optional)</param>
        /// <param name="deploymentId">Filter by the deployment the id belongs to. (optional)</param>
        /// <param name="superProcessInstance">Restrict query to all process instances that are sub process instances of the given process instance. Takes a process instance id. (optional)</param>
        /// <param name="subProcessInstance">Restrict query to all process instances that have the given process instance as a sub process instance. Takes a process instance id. (optional)</param>
        /// <param name="superCaseInstance">Restrict query to all process instances that are sub process instances of the given case instance. Takes a case instance id. (optional)</param>
        /// <param name="subCaseInstance">Restrict query to all process instances that have the given case instance as a sub case instance. Takes a case instance id. (optional)</param>
        /// <param name="active">Only include active process instances. Value may only be true, as false is the default behavior. (optional, default to false)</param>
        /// <param name="suspended">Only include suspended process instances. Value may only be true, as false is the default behavior. (optional, default to false)</param>
        /// <param name="withIncident">Filter by presence of incidents. Selects only process instances that have an incident. (optional, default to false)</param>
        /// <param name="incidentId">Filter by the incident id. (optional)</param>
        /// <param name="incidentType">Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)</param>
        /// <param name="incidentMessage">Filter by the incident message. Exact match. (optional)</param>
        /// <param name="incidentMessageLike">Filter by the incident message that the parameter is a substring of. (optional)</param>
        /// <param name="tenantIdIn">Filter by a comma-separated list of tenant ids. A process instance must have one of the given tenant ids. (optional)</param>
        /// <param name="withoutTenantId">Only include process instances which belong to no tenant. (optional, default to false)</param>
        /// <param name="processDefinitionWithoutTenantId">Only include process instances which process definition has no tenant id. (optional, default to false)</param>
        /// <param name="activityIdIn">Filter by a comma-separated list of activity ids. A process instance must currently wait in a leaf activity with one of the given activity ids. (optional)</param>
        /// <param name="rootProcessInstances">Restrict the query to all process instances that are top level process instances. (optional, default to false)</param>
        /// <param name="leafProcessInstances">Restrict the query to all process instances that are leaf instances. (i.e. don&#x27;t have any sub instances). (optional, default to false)</param>
        /// <param name="variables">Only include process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)</param>
        /// <param name="variableNamesIgnoreCase">Match all variable names in this query case-insensitively. If set to true variableName and variablename are treated as equal. (optional, default to false)</param>
        /// <param name="variableValuesIgnoreCase">Match all variable values in this query case-insensitively. If set to true variableValue and variablevalue are treated as equal. (optional, default to false)</param>
        /// <returns>CountResultDto</returns>
        public CountResultDto GetProcessInstancesCount (string processInstanceIds = null, string businessKey = null, string businessKeyLike = null, string caseInstanceId = null, string processDefinitionId = null, string processDefinitionKey = null, string processDefinitionKeyIn = null, string processDefinitionKeyNotIn = null, string deploymentId = null, string superProcessInstance = null, string subProcessInstance = null, string superCaseInstance = null, string subCaseInstance = null, bool? active = null, bool? suspended = null, bool? withIncident = null, string incidentId = null, string incidentType = null, string incidentMessage = null, string incidentMessageLike = null, string tenantIdIn = null, bool? withoutTenantId = null, bool? processDefinitionWithoutTenantId = null, string activityIdIn = null, bool? rootProcessInstances = null, bool? leafProcessInstances = null, string variables = null, bool? variableNamesIgnoreCase = null, bool? variableValuesIgnoreCase = null)
        {
             ApiResponse<CountResultDto> localVarResponse = GetProcessInstancesCountWithHttpInfo(processInstanceIds, businessKey, businessKeyLike, caseInstanceId, processDefinitionId, processDefinitionKey, processDefinitionKeyIn, processDefinitionKeyNotIn, deploymentId, superProcessInstance, subProcessInstance, superCaseInstance, subCaseInstance, active, suspended, withIncident, incidentId, incidentType, incidentMessage, incidentMessageLike, tenantIdIn, withoutTenantId, processDefinitionWithoutTenantId, activityIdIn, rootProcessInstances, leafProcessInstances, variables, variableNamesIgnoreCase, variableValuesIgnoreCase);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  Queries for the number of process instances that fulfill given parameters.
        /// </summary>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="processInstanceIds">Filter by a comma-separated list of process instance ids. (optional)</param>
        /// <param name="businessKey">Filter by process instance business key. (optional)</param>
        /// <param name="businessKeyLike">Filter by process instance business key that the parameter is a substring of. (optional)</param>
        /// <param name="caseInstanceId">Filter by case instance id. (optional)</param>
        /// <param name="processDefinitionId">Filter by the deployment the id belongs to. (optional)</param>
        /// <param name="processDefinitionKey">Filter by the key of the process definition the instances run on. (optional)</param>
        /// <param name="processDefinitionKeyIn">Filter by a comma-separated list of process definition keys. A process instance must have one of the given process definition keys. (optional)</param>
        /// <param name="processDefinitionKeyNotIn">Exclude instances by a comma-separated list of process definition keys. A process instance must not have one of the given process definition keys. (optional)</param>
        /// <param name="deploymentId">Filter by the deployment the id belongs to. (optional)</param>
        /// <param name="superProcessInstance">Restrict query to all process instances that are sub process instances of the given process instance. Takes a process instance id. (optional)</param>
        /// <param name="subProcessInstance">Restrict query to all process instances that have the given process instance as a sub process instance. Takes a process instance id. (optional)</param>
        /// <param name="superCaseInstance">Restrict query to all process instances that are sub process instances of the given case instance. Takes a case instance id. (optional)</param>
        /// <param name="subCaseInstance">Restrict query to all process instances that have the given case instance as a sub case instance. Takes a case instance id. (optional)</param>
        /// <param name="active">Only include active process instances. Value may only be true, as false is the default behavior. (optional, default to false)</param>
        /// <param name="suspended">Only include suspended process instances. Value may only be true, as false is the default behavior. (optional, default to false)</param>
        /// <param name="withIncident">Filter by presence of incidents. Selects only process instances that have an incident. (optional, default to false)</param>
        /// <param name="incidentId">Filter by the incident id. (optional)</param>
        /// <param name="incidentType">Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)</param>
        /// <param name="incidentMessage">Filter by the incident message. Exact match. (optional)</param>
        /// <param name="incidentMessageLike">Filter by the incident message that the parameter is a substring of. (optional)</param>
        /// <param name="tenantIdIn">Filter by a comma-separated list of tenant ids. A process instance must have one of the given tenant ids. (optional)</param>
        /// <param name="withoutTenantId">Only include process instances which belong to no tenant. (optional, default to false)</param>
        /// <param name="processDefinitionWithoutTenantId">Only include process instances which process definition has no tenant id. (optional, default to false)</param>
        /// <param name="activityIdIn">Filter by a comma-separated list of activity ids. A process instance must currently wait in a leaf activity with one of the given activity ids. (optional)</param>
        /// <param name="rootProcessInstances">Restrict the query to all process instances that are top level process instances. (optional, default to false)</param>
        /// <param name="leafProcessInstances">Restrict the query to all process instances that are leaf instances. (i.e. don&#x27;t have any sub instances). (optional, default to false)</param>
        /// <param name="variables">Only include process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)</param>
        /// <param name="variableNamesIgnoreCase">Match all variable names in this query case-insensitively. If set to true variableName and variablename are treated as equal. (optional, default to false)</param>
        /// <param name="variableValuesIgnoreCase">Match all variable values in this query case-insensitively. If set to true variableValue and variablevalue are treated as equal. (optional, default to false)</param>
        /// <returns>ApiResponse of CountResultDto</returns>
        public ApiResponse< CountResultDto > GetProcessInstancesCountWithHttpInfo (string processInstanceIds = null, string businessKey = null, string businessKeyLike = null, string caseInstanceId = null, string processDefinitionId = null, string processDefinitionKey = null, string processDefinitionKeyIn = null, string processDefinitionKeyNotIn = null, string deploymentId = null, string superProcessInstance = null, string subProcessInstance = null, string superCaseInstance = null, string subCaseInstance = null, bool? active = null, bool? suspended = null, bool? withIncident = null, string incidentId = null, string incidentType = null, string incidentMessage = null, string incidentMessageLike = null, string tenantIdIn = null, bool? withoutTenantId = null, bool? processDefinitionWithoutTenantId = null, string activityIdIn = null, bool? rootProcessInstances = null, bool? leafProcessInstances = null, string variables = null, bool? variableNamesIgnoreCase = null, bool? variableValuesIgnoreCase = null)
        {

            var localVarPath = "/process-instance/count";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (processInstanceIds != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "processInstanceIds", processInstanceIds)); // query parameter
            if (businessKey != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "businessKey", businessKey)); // query parameter
            if (businessKeyLike != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "businessKeyLike", businessKeyLike)); // query parameter
            if (caseInstanceId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "caseInstanceId", caseInstanceId)); // query parameter
            if (processDefinitionId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "processDefinitionId", processDefinitionId)); // query parameter
            if (processDefinitionKey != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "processDefinitionKey", processDefinitionKey)); // query parameter
            if (processDefinitionKeyIn != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "processDefinitionKeyIn", processDefinitionKeyIn)); // query parameter
            if (processDefinitionKeyNotIn != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "processDefinitionKeyNotIn", processDefinitionKeyNotIn)); // query parameter
            if (deploymentId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "deploymentId", deploymentId)); // query parameter
            if (superProcessInstance != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "superProcessInstance", superProcessInstance)); // query parameter
            if (subProcessInstance != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "subProcessInstance", subProcessInstance)); // query parameter
            if (superCaseInstance != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "superCaseInstance", superCaseInstance)); // query parameter
            if (subCaseInstance != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "subCaseInstance", subCaseInstance)); // query parameter
            if (active != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "active", active)); // query parameter
            if (suspended != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "suspended", suspended)); // query parameter
            if (withIncident != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "withIncident", withIncident)); // query parameter
            if (incidentId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "incidentId", incidentId)); // query parameter
            if (incidentType != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "incidentType", incidentType)); // query parameter
            if (incidentMessage != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "incidentMessage", incidentMessage)); // query parameter
            if (incidentMessageLike != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "incidentMessageLike", incidentMessageLike)); // query parameter
            if (tenantIdIn != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "tenantIdIn", tenantIdIn)); // query parameter
            if (withoutTenantId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "withoutTenantId", withoutTenantId)); // query parameter
            if (processDefinitionWithoutTenantId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "processDefinitionWithoutTenantId", processDefinitionWithoutTenantId)); // query parameter
            if (activityIdIn != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "activityIdIn", activityIdIn)); // query parameter
            if (rootProcessInstances != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "rootProcessInstances", rootProcessInstances)); // query parameter
            if (leafProcessInstances != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "leafProcessInstances", leafProcessInstances)); // query parameter
            if (variables != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "variables", variables)); // query parameter
            if (variableNamesIgnoreCase != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "variableNamesIgnoreCase", variableNamesIgnoreCase)); // query parameter
            if (variableValuesIgnoreCase != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "variableValuesIgnoreCase", variableValuesIgnoreCase)); // query parameter

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetProcessInstancesCount", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<CountResultDto>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (CountResultDto) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(CountResultDto)));
        }

        /// <summary>
        ///  Queries for the number of process instances that fulfill given parameters.
        /// </summary>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="processInstanceIds">Filter by a comma-separated list of process instance ids. (optional)</param>
        /// <param name="businessKey">Filter by process instance business key. (optional)</param>
        /// <param name="businessKeyLike">Filter by process instance business key that the parameter is a substring of. (optional)</param>
        /// <param name="caseInstanceId">Filter by case instance id. (optional)</param>
        /// <param name="processDefinitionId">Filter by the deployment the id belongs to. (optional)</param>
        /// <param name="processDefinitionKey">Filter by the key of the process definition the instances run on. (optional)</param>
        /// <param name="processDefinitionKeyIn">Filter by a comma-separated list of process definition keys. A process instance must have one of the given process definition keys. (optional)</param>
        /// <param name="processDefinitionKeyNotIn">Exclude instances by a comma-separated list of process definition keys. A process instance must not have one of the given process definition keys. (optional)</param>
        /// <param name="deploymentId">Filter by the deployment the id belongs to. (optional)</param>
        /// <param name="superProcessInstance">Restrict query to all process instances that are sub process instances of the given process instance. Takes a process instance id. (optional)</param>
        /// <param name="subProcessInstance">Restrict query to all process instances that have the given process instance as a sub process instance. Takes a process instance id. (optional)</param>
        /// <param name="superCaseInstance">Restrict query to all process instances that are sub process instances of the given case instance. Takes a case instance id. (optional)</param>
        /// <param name="subCaseInstance">Restrict query to all process instances that have the given case instance as a sub case instance. Takes a case instance id. (optional)</param>
        /// <param name="active">Only include active process instances. Value may only be true, as false is the default behavior. (optional, default to false)</param>
        /// <param name="suspended">Only include suspended process instances. Value may only be true, as false is the default behavior. (optional, default to false)</param>
        /// <param name="withIncident">Filter by presence of incidents. Selects only process instances that have an incident. (optional, default to false)</param>
        /// <param name="incidentId">Filter by the incident id. (optional)</param>
        /// <param name="incidentType">Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)</param>
        /// <param name="incidentMessage">Filter by the incident message. Exact match. (optional)</param>
        /// <param name="incidentMessageLike">Filter by the incident message that the parameter is a substring of. (optional)</param>
        /// <param name="tenantIdIn">Filter by a comma-separated list of tenant ids. A process instance must have one of the given tenant ids. (optional)</param>
        /// <param name="withoutTenantId">Only include process instances which belong to no tenant. (optional, default to false)</param>
        /// <param name="processDefinitionWithoutTenantId">Only include process instances which process definition has no tenant id. (optional, default to false)</param>
        /// <param name="activityIdIn">Filter by a comma-separated list of activity ids. A process instance must currently wait in a leaf activity with one of the given activity ids. (optional)</param>
        /// <param name="rootProcessInstances">Restrict the query to all process instances that are top level process instances. (optional, default to false)</param>
        /// <param name="leafProcessInstances">Restrict the query to all process instances that are leaf instances. (i.e. don&#x27;t have any sub instances). (optional, default to false)</param>
        /// <param name="variables">Only include process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)</param>
        /// <param name="variableNamesIgnoreCase">Match all variable names in this query case-insensitively. If set to true variableName and variablename are treated as equal. (optional, default to false)</param>
        /// <param name="variableValuesIgnoreCase">Match all variable values in this query case-insensitively. If set to true variableValue and variablevalue are treated as equal. (optional, default to false)</param>
        /// <returns>Task of CountResultDto</returns>
        public async System.Threading.Tasks.Task<CountResultDto> GetProcessInstancesCountAsync (string processInstanceIds = null, string businessKey = null, string businessKeyLike = null, string caseInstanceId = null, string processDefinitionId = null, string processDefinitionKey = null, string processDefinitionKeyIn = null, string processDefinitionKeyNotIn = null, string deploymentId = null, string superProcessInstance = null, string subProcessInstance = null, string superCaseInstance = null, string subCaseInstance = null, bool? active = null, bool? suspended = null, bool? withIncident = null, string incidentId = null, string incidentType = null, string incidentMessage = null, string incidentMessageLike = null, string tenantIdIn = null, bool? withoutTenantId = null, bool? processDefinitionWithoutTenantId = null, string activityIdIn = null, bool? rootProcessInstances = null, bool? leafProcessInstances = null, string variables = null, bool? variableNamesIgnoreCase = null, bool? variableValuesIgnoreCase = null)
        {
             ApiResponse<CountResultDto> localVarResponse = await GetProcessInstancesCountAsyncWithHttpInfo(processInstanceIds, businessKey, businessKeyLike, caseInstanceId, processDefinitionId, processDefinitionKey, processDefinitionKeyIn, processDefinitionKeyNotIn, deploymentId, superProcessInstance, subProcessInstance, superCaseInstance, subCaseInstance, active, suspended, withIncident, incidentId, incidentType, incidentMessage, incidentMessageLike, tenantIdIn, withoutTenantId, processDefinitionWithoutTenantId, activityIdIn, rootProcessInstances, leafProcessInstances, variables, variableNamesIgnoreCase, variableValuesIgnoreCase);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  Queries for the number of process instances that fulfill given parameters.
        /// </summary>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="processInstanceIds">Filter by a comma-separated list of process instance ids. (optional)</param>
        /// <param name="businessKey">Filter by process instance business key. (optional)</param>
        /// <param name="businessKeyLike">Filter by process instance business key that the parameter is a substring of. (optional)</param>
        /// <param name="caseInstanceId">Filter by case instance id. (optional)</param>
        /// <param name="processDefinitionId">Filter by the deployment the id belongs to. (optional)</param>
        /// <param name="processDefinitionKey">Filter by the key of the process definition the instances run on. (optional)</param>
        /// <param name="processDefinitionKeyIn">Filter by a comma-separated list of process definition keys. A process instance must have one of the given process definition keys. (optional)</param>
        /// <param name="processDefinitionKeyNotIn">Exclude instances by a comma-separated list of process definition keys. A process instance must not have one of the given process definition keys. (optional)</param>
        /// <param name="deploymentId">Filter by the deployment the id belongs to. (optional)</param>
        /// <param name="superProcessInstance">Restrict query to all process instances that are sub process instances of the given process instance. Takes a process instance id. (optional)</param>
        /// <param name="subProcessInstance">Restrict query to all process instances that have the given process instance as a sub process instance. Takes a process instance id. (optional)</param>
        /// <param name="superCaseInstance">Restrict query to all process instances that are sub process instances of the given case instance. Takes a case instance id. (optional)</param>
        /// <param name="subCaseInstance">Restrict query to all process instances that have the given case instance as a sub case instance. Takes a case instance id. (optional)</param>
        /// <param name="active">Only include active process instances. Value may only be true, as false is the default behavior. (optional, default to false)</param>
        /// <param name="suspended">Only include suspended process instances. Value may only be true, as false is the default behavior. (optional, default to false)</param>
        /// <param name="withIncident">Filter by presence of incidents. Selects only process instances that have an incident. (optional, default to false)</param>
        /// <param name="incidentId">Filter by the incident id. (optional)</param>
        /// <param name="incidentType">Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)</param>
        /// <param name="incidentMessage">Filter by the incident message. Exact match. (optional)</param>
        /// <param name="incidentMessageLike">Filter by the incident message that the parameter is a substring of. (optional)</param>
        /// <param name="tenantIdIn">Filter by a comma-separated list of tenant ids. A process instance must have one of the given tenant ids. (optional)</param>
        /// <param name="withoutTenantId">Only include process instances which belong to no tenant. (optional, default to false)</param>
        /// <param name="processDefinitionWithoutTenantId">Only include process instances which process definition has no tenant id. (optional, default to false)</param>
        /// <param name="activityIdIn">Filter by a comma-separated list of activity ids. A process instance must currently wait in a leaf activity with one of the given activity ids. (optional)</param>
        /// <param name="rootProcessInstances">Restrict the query to all process instances that are top level process instances. (optional, default to false)</param>
        /// <param name="leafProcessInstances">Restrict the query to all process instances that are leaf instances. (i.e. don&#x27;t have any sub instances). (optional, default to false)</param>
        /// <param name="variables">Only include process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)</param>
        /// <param name="variableNamesIgnoreCase">Match all variable names in this query case-insensitively. If set to true variableName and variablename are treated as equal. (optional, default to false)</param>
        /// <param name="variableValuesIgnoreCase">Match all variable values in this query case-insensitively. If set to true variableValue and variablevalue are treated as equal. (optional, default to false)</param>
        /// <returns>Task of ApiResponse (CountResultDto)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<CountResultDto>> GetProcessInstancesCountAsyncWithHttpInfo (string processInstanceIds = null, string businessKey = null, string businessKeyLike = null, string caseInstanceId = null, string processDefinitionId = null, string processDefinitionKey = null, string processDefinitionKeyIn = null, string processDefinitionKeyNotIn = null, string deploymentId = null, string superProcessInstance = null, string subProcessInstance = null, string superCaseInstance = null, string subCaseInstance = null, bool? active = null, bool? suspended = null, bool? withIncident = null, string incidentId = null, string incidentType = null, string incidentMessage = null, string incidentMessageLike = null, string tenantIdIn = null, bool? withoutTenantId = null, bool? processDefinitionWithoutTenantId = null, string activityIdIn = null, bool? rootProcessInstances = null, bool? leafProcessInstances = null, string variables = null, bool? variableNamesIgnoreCase = null, bool? variableValuesIgnoreCase = null)
        {

            var localVarPath = "/process-instance/count";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (processInstanceIds != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "processInstanceIds", processInstanceIds)); // query parameter
            if (businessKey != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "businessKey", businessKey)); // query parameter
            if (businessKeyLike != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "businessKeyLike", businessKeyLike)); // query parameter
            if (caseInstanceId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "caseInstanceId", caseInstanceId)); // query parameter
            if (processDefinitionId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "processDefinitionId", processDefinitionId)); // query parameter
            if (processDefinitionKey != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "processDefinitionKey", processDefinitionKey)); // query parameter
            if (processDefinitionKeyIn != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "processDefinitionKeyIn", processDefinitionKeyIn)); // query parameter
            if (processDefinitionKeyNotIn != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "processDefinitionKeyNotIn", processDefinitionKeyNotIn)); // query parameter
            if (deploymentId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "deploymentId", deploymentId)); // query parameter
            if (superProcessInstance != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "superProcessInstance", superProcessInstance)); // query parameter
            if (subProcessInstance != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "subProcessInstance", subProcessInstance)); // query parameter
            if (superCaseInstance != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "superCaseInstance", superCaseInstance)); // query parameter
            if (subCaseInstance != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "subCaseInstance", subCaseInstance)); // query parameter
            if (active != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "active", active)); // query parameter
            if (suspended != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "suspended", suspended)); // query parameter
            if (withIncident != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "withIncident", withIncident)); // query parameter
            if (incidentId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "incidentId", incidentId)); // query parameter
            if (incidentType != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "incidentType", incidentType)); // query parameter
            if (incidentMessage != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "incidentMessage", incidentMessage)); // query parameter
            if (incidentMessageLike != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "incidentMessageLike", incidentMessageLike)); // query parameter
            if (tenantIdIn != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "tenantIdIn", tenantIdIn)); // query parameter
            if (withoutTenantId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "withoutTenantId", withoutTenantId)); // query parameter
            if (processDefinitionWithoutTenantId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "processDefinitionWithoutTenantId", processDefinitionWithoutTenantId)); // query parameter
            if (activityIdIn != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "activityIdIn", activityIdIn)); // query parameter
            if (rootProcessInstances != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "rootProcessInstances", rootProcessInstances)); // query parameter
            if (leafProcessInstances != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "leafProcessInstances", leafProcessInstances)); // query parameter
            if (variables != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "variables", variables)); // query parameter
            if (variableNamesIgnoreCase != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "variableNamesIgnoreCase", variableNamesIgnoreCase)); // query parameter
            if (variableValuesIgnoreCase != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "variableValuesIgnoreCase", variableValuesIgnoreCase)); // query parameter

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetProcessInstancesCount", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<CountResultDto>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (CountResultDto) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(CountResultDto)));
        }

        /// <summary>
        ///  Submits a list of modification instructions to change a process instance&#x27;s execution state. A modification instruction is one of the following:  * Starting execution before an activity * Starting execution after an activity on its single outgoing sequence flow * Starting execution on a specific sequence flow * Canceling an activity instance, transition instance, or all instances (activity or transition) for an activity  Instructions are executed immediately and in the order they are provided in this request&#x27;s body. Variables can be provided with every starting instruction.  The exact semantics of modification can be read about in the [User guide](https://docs.camunda.org/manual/develop/user-guide/process-engine/process-instance-modification/).
        /// </summary>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to modify.</param>
        /// <param name="body"> (optional)</param>
        /// <returns></returns>
        public void ModifyProcessInstance (string id, ProcessInstanceModificationDto body = null)
        {
             ModifyProcessInstanceWithHttpInfo(id, body);
        }

        /// <summary>
        ///  Submits a list of modification instructions to change a process instance&#x27;s execution state. A modification instruction is one of the following:  * Starting execution before an activity * Starting execution after an activity on its single outgoing sequence flow * Starting execution on a specific sequence flow * Canceling an activity instance, transition instance, or all instances (activity or transition) for an activity  Instructions are executed immediately and in the order they are provided in this request&#x27;s body. Variables can be provided with every starting instruction.  The exact semantics of modification can be read about in the [User guide](https://docs.camunda.org/manual/develop/user-guide/process-engine/process-instance-modification/).
        /// </summary>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to modify.</param>
        /// <param name="body"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ModifyProcessInstanceWithHttpInfo (string id, ProcessInstanceModificationDto body = null)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling ProcessInstanceApi->ModifyProcessInstance");

            var localVarPath = "/process-instance/{id}/modification";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ModifyProcessInstance", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        ///  Submits a list of modification instructions to change a process instance&#x27;s execution state. A modification instruction is one of the following:  * Starting execution before an activity * Starting execution after an activity on its single outgoing sequence flow * Starting execution on a specific sequence flow * Canceling an activity instance, transition instance, or all instances (activity or transition) for an activity  Instructions are executed immediately and in the order they are provided in this request&#x27;s body. Variables can be provided with every starting instruction.  The exact semantics of modification can be read about in the [User guide](https://docs.camunda.org/manual/develop/user-guide/process-engine/process-instance-modification/).
        /// </summary>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to modify.</param>
        /// <param name="body"> (optional)</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task ModifyProcessInstanceAsync (string id, ProcessInstanceModificationDto body = null)
        {
             await ModifyProcessInstanceAsyncWithHttpInfo(id, body);

        }

        /// <summary>
        ///  Submits a list of modification instructions to change a process instance&#x27;s execution state. A modification instruction is one of the following:  * Starting execution before an activity * Starting execution after an activity on its single outgoing sequence flow * Starting execution on a specific sequence flow * Canceling an activity instance, transition instance, or all instances (activity or transition) for an activity  Instructions are executed immediately and in the order they are provided in this request&#x27;s body. Variables can be provided with every starting instruction.  The exact semantics of modification can be read about in the [User guide](https://docs.camunda.org/manual/develop/user-guide/process-engine/process-instance-modification/).
        /// </summary>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to modify.</param>
        /// <param name="body"> (optional)</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> ModifyProcessInstanceAsyncWithHttpInfo (string id, ProcessInstanceModificationDto body = null)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling ProcessInstanceApi->ModifyProcessInstance");

            var localVarPath = "/process-instance/{id}/modification";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ModifyProcessInstance", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        ///  Submits a list of modification instructions to change a process instance&#x27;s execution state async. A modification instruction is one of the following:  * Starting execution before an activity * Starting execution after an activity on its single outgoing sequence flow * Starting execution on a specific sequence flow * Cancelling an activity instance, transition instance, or all instances (activity or transition) for an activity  Instructions are executed asynchronous and in the order they are provided in this request&#x27;s body. Variables can be provided with every starting instruction.  The exact semantics of modification can be read about in the [User guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/process-instance-modification/).
        /// </summary>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to modify.</param>
        /// <param name="body"> (optional)</param>
        /// <returns>BatchDto</returns>
        public BatchDto ModifyProcessInstanceAsyncOperation (string id, ProcessInstanceModificationDto body = null)
        {
             ApiResponse<BatchDto> localVarResponse = ModifyProcessInstanceAsyncOperationWithHttpInfo(id, body);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  Submits a list of modification instructions to change a process instance&#x27;s execution state async. A modification instruction is one of the following:  * Starting execution before an activity * Starting execution after an activity on its single outgoing sequence flow * Starting execution on a specific sequence flow * Cancelling an activity instance, transition instance, or all instances (activity or transition) for an activity  Instructions are executed asynchronous and in the order they are provided in this request&#x27;s body. Variables can be provided with every starting instruction.  The exact semantics of modification can be read about in the [User guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/process-instance-modification/).
        /// </summary>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to modify.</param>
        /// <param name="body"> (optional)</param>
        /// <returns>ApiResponse of BatchDto</returns>
        public ApiResponse< BatchDto > ModifyProcessInstanceAsyncOperationWithHttpInfo (string id, ProcessInstanceModificationDto body = null)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling ProcessInstanceApi->ModifyProcessInstanceAsyncOperation");

            var localVarPath = "/process-instance/{id}/modification-async";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ModifyProcessInstanceAsyncOperation", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<BatchDto>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (BatchDto) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(BatchDto)));
        }

        /// <summary>
        ///  Submits a list of modification instructions to change a process instance&#x27;s execution state async. A modification instruction is one of the following:  * Starting execution before an activity * Starting execution after an activity on its single outgoing sequence flow * Starting execution on a specific sequence flow * Cancelling an activity instance, transition instance, or all instances (activity or transition) for an activity  Instructions are executed asynchronous and in the order they are provided in this request&#x27;s body. Variables can be provided with every starting instruction.  The exact semantics of modification can be read about in the [User guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/process-instance-modification/).
        /// </summary>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to modify.</param>
        /// <param name="body"> (optional)</param>
        /// <returns>Task of BatchDto</returns>
        public async System.Threading.Tasks.Task<BatchDto> ModifyProcessInstanceAsyncOperationAsync (string id, ProcessInstanceModificationDto body = null)
        {
             ApiResponse<BatchDto> localVarResponse = await ModifyProcessInstanceAsyncOperationAsyncWithHttpInfo(id, body);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  Submits a list of modification instructions to change a process instance&#x27;s execution state async. A modification instruction is one of the following:  * Starting execution before an activity * Starting execution after an activity on its single outgoing sequence flow * Starting execution on a specific sequence flow * Cancelling an activity instance, transition instance, or all instances (activity or transition) for an activity  Instructions are executed asynchronous and in the order they are provided in this request&#x27;s body. Variables can be provided with every starting instruction.  The exact semantics of modification can be read about in the [User guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/process-instance-modification/).
        /// </summary>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to modify.</param>
        /// <param name="body"> (optional)</param>
        /// <returns>Task of ApiResponse (BatchDto)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<BatchDto>> ModifyProcessInstanceAsyncOperationAsyncWithHttpInfo (string id, ProcessInstanceModificationDto body = null)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling ProcessInstanceApi->ModifyProcessInstanceAsyncOperation");

            var localVarPath = "/process-instance/{id}/modification-async";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ModifyProcessInstanceAsyncOperation", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<BatchDto>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (BatchDto) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(BatchDto)));
        }

        /// <summary>
        ///  Updates or deletes the variables of a process instance by id. Updates precede deletions. So, if a variable is updated AND deleted, the deletion overrides the update.
        /// </summary>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to set variables for.</param>
        /// <param name="body"> (optional)</param>
        /// <returns></returns>
        public void ModifyProcessInstanceVariables (string id, PatchVariablesDto body = null)
        {
             ModifyProcessInstanceVariablesWithHttpInfo(id, body);
        }

        /// <summary>
        ///  Updates or deletes the variables of a process instance by id. Updates precede deletions. So, if a variable is updated AND deleted, the deletion overrides the update.
        /// </summary>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to set variables for.</param>
        /// <param name="body"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ModifyProcessInstanceVariablesWithHttpInfo (string id, PatchVariablesDto body = null)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling ProcessInstanceApi->ModifyProcessInstanceVariables");

            var localVarPath = "/process-instance/{id}/variables";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ModifyProcessInstanceVariables", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        ///  Updates or deletes the variables of a process instance by id. Updates precede deletions. So, if a variable is updated AND deleted, the deletion overrides the update.
        /// </summary>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to set variables for.</param>
        /// <param name="body"> (optional)</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task ModifyProcessInstanceVariablesAsync (string id, PatchVariablesDto body = null)
        {
             await ModifyProcessInstanceVariablesAsyncWithHttpInfo(id, body);

        }

        /// <summary>
        ///  Updates or deletes the variables of a process instance by id. Updates precede deletions. So, if a variable is updated AND deleted, the deletion overrides the update.
        /// </summary>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to set variables for.</param>
        /// <param name="body"> (optional)</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> ModifyProcessInstanceVariablesAsyncWithHttpInfo (string id, PatchVariablesDto body = null)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling ProcessInstanceApi->ModifyProcessInstanceVariables");

            var localVarPath = "/process-instance/{id}/variables";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ModifyProcessInstanceVariables", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        ///  Queries for process instances that fulfill given parameters through a JSON object. This method is slightly more powerful than the Get Instances method because it allows filtering by multiple process variables of types &#x60;string&#x60;, &#x60;number&#x60; or &#x60;boolean&#x60;.
        /// </summary>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"> (optional)</param>
        /// <param name="firstResult">Pagination of results. Specifies the index of the first result to return. (optional)</param>
        /// <param name="maxResults">Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)</param>
        /// <returns>List&lt;ProcessInstanceDto&gt;</returns>
        public List<ProcessInstanceDto> QueryProcessInstances (ProcessInstanceQueryDto body = null, int? firstResult = null, int? maxResults = null)
        {
             ApiResponse<List<ProcessInstanceDto>> localVarResponse = QueryProcessInstancesWithHttpInfo(body, firstResult, maxResults);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  Queries for process instances that fulfill given parameters through a JSON object. This method is slightly more powerful than the Get Instances method because it allows filtering by multiple process variables of types &#x60;string&#x60;, &#x60;number&#x60; or &#x60;boolean&#x60;.
        /// </summary>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"> (optional)</param>
        /// <param name="firstResult">Pagination of results. Specifies the index of the first result to return. (optional)</param>
        /// <param name="maxResults">Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)</param>
        /// <returns>ApiResponse of List&lt;ProcessInstanceDto&gt;</returns>
        public ApiResponse< List<ProcessInstanceDto> > QueryProcessInstancesWithHttpInfo (ProcessInstanceQueryDto body = null, int? firstResult = null, int? maxResults = null)
        {

            var localVarPath = "/process-instance";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (firstResult != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "firstResult", firstResult)); // query parameter
            if (maxResults != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "maxResults", maxResults)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("QueryProcessInstances", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<List<ProcessInstanceDto>>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (List<ProcessInstanceDto>) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(List<ProcessInstanceDto>)));
        }

        /// <summary>
        ///  Queries for process instances that fulfill given parameters through a JSON object. This method is slightly more powerful than the Get Instances method because it allows filtering by multiple process variables of types &#x60;string&#x60;, &#x60;number&#x60; or &#x60;boolean&#x60;.
        /// </summary>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"> (optional)</param>
        /// <param name="firstResult">Pagination of results. Specifies the index of the first result to return. (optional)</param>
        /// <param name="maxResults">Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)</param>
        /// <returns>Task of List&lt;ProcessInstanceDto&gt;</returns>
        public async System.Threading.Tasks.Task<List<ProcessInstanceDto>> QueryProcessInstancesAsync (ProcessInstanceQueryDto body = null, int? firstResult = null, int? maxResults = null)
        {
             ApiResponse<List<ProcessInstanceDto>> localVarResponse = await QueryProcessInstancesAsyncWithHttpInfo(body, firstResult, maxResults);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  Queries for process instances that fulfill given parameters through a JSON object. This method is slightly more powerful than the Get Instances method because it allows filtering by multiple process variables of types &#x60;string&#x60;, &#x60;number&#x60; or &#x60;boolean&#x60;.
        /// </summary>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"> (optional)</param>
        /// <param name="firstResult">Pagination of results. Specifies the index of the first result to return. (optional)</param>
        /// <param name="maxResults">Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;ProcessInstanceDto&gt;)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<List<ProcessInstanceDto>>> QueryProcessInstancesAsyncWithHttpInfo (ProcessInstanceQueryDto body = null, int? firstResult = null, int? maxResults = null)
        {

            var localVarPath = "/process-instance";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (firstResult != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "firstResult", firstResult)); // query parameter
            if (maxResults != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "maxResults", maxResults)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("QueryProcessInstances", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<List<ProcessInstanceDto>>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (List<ProcessInstanceDto>) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(List<ProcessInstanceDto>)));
        }

        /// <summary>
        ///  Queries for the number of process instances that fulfill the given parameters. This method takes the same message body as the Get Instances (POST) method and therefore it is slightly more powerful than the Get Instance Count method.
        /// </summary>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"> (optional)</param>
        /// <returns>CountResultDto</returns>
        public CountResultDto QueryProcessInstancesCount (ProcessInstanceQueryDto body = null)
        {
             ApiResponse<CountResultDto> localVarResponse = QueryProcessInstancesCountWithHttpInfo(body);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  Queries for the number of process instances that fulfill the given parameters. This method takes the same message body as the Get Instances (POST) method and therefore it is slightly more powerful than the Get Instance Count method.
        /// </summary>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"> (optional)</param>
        /// <returns>ApiResponse of CountResultDto</returns>
        public ApiResponse< CountResultDto > QueryProcessInstancesCountWithHttpInfo (ProcessInstanceQueryDto body = null)
        {

            var localVarPath = "/process-instance/count";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("QueryProcessInstancesCount", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<CountResultDto>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (CountResultDto) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(CountResultDto)));
        }

        /// <summary>
        ///  Queries for the number of process instances that fulfill the given parameters. This method takes the same message body as the Get Instances (POST) method and therefore it is slightly more powerful than the Get Instance Count method.
        /// </summary>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"> (optional)</param>
        /// <returns>Task of CountResultDto</returns>
        public async System.Threading.Tasks.Task<CountResultDto> QueryProcessInstancesCountAsync (ProcessInstanceQueryDto body = null)
        {
             ApiResponse<CountResultDto> localVarResponse = await QueryProcessInstancesCountAsyncWithHttpInfo(body);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  Queries for the number of process instances that fulfill the given parameters. This method takes the same message body as the Get Instances (POST) method and therefore it is slightly more powerful than the Get Instance Count method.
        /// </summary>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"> (optional)</param>
        /// <returns>Task of ApiResponse (CountResultDto)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<CountResultDto>> QueryProcessInstancesCountAsyncWithHttpInfo (ProcessInstanceQueryDto body = null)
        {

            var localVarPath = "/process-instance/count";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("QueryProcessInstancesCount", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<CountResultDto>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (CountResultDto) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(CountResultDto)));
        }

        /// <summary>
        ///  Sets a variable of a given process instance by id.
        /// </summary>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to set the variable for.</param>
        /// <param name="varName">The name of the variable to set.</param>
        /// <param name="body"> (optional)</param>
        /// <returns></returns>
        public void SetProcessInstanceVariable (string id, string varName, VariableValueDto body = null)
        {
             SetProcessInstanceVariableWithHttpInfo(id, varName, body);
        }

        /// <summary>
        ///  Sets a variable of a given process instance by id.
        /// </summary>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to set the variable for.</param>
        /// <param name="varName">The name of the variable to set.</param>
        /// <param name="body"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> SetProcessInstanceVariableWithHttpInfo (string id, string varName, VariableValueDto body = null)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling ProcessInstanceApi->SetProcessInstanceVariable");
            // verify the required parameter 'varName' is set
            if (varName == null)
                throw new ApiException(400, "Missing required parameter 'varName' when calling ProcessInstanceApi->SetProcessInstanceVariable");

            var localVarPath = "/process-instance/{id}/variables/{varName}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (varName != null) localVarPathParams.Add("varName", this.Configuration.ApiClient.ParameterToString(varName)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("SetProcessInstanceVariable", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        ///  Sets a variable of a given process instance by id.
        /// </summary>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to set the variable for.</param>
        /// <param name="varName">The name of the variable to set.</param>
        /// <param name="body"> (optional)</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task SetProcessInstanceVariableAsync (string id, string varName, VariableValueDto body = null)
        {
             await SetProcessInstanceVariableAsyncWithHttpInfo(id, varName, body);

        }

        /// <summary>
        ///  Sets a variable of a given process instance by id.
        /// </summary>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to set the variable for.</param>
        /// <param name="varName">The name of the variable to set.</param>
        /// <param name="body"> (optional)</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> SetProcessInstanceVariableAsyncWithHttpInfo (string id, string varName, VariableValueDto body = null)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling ProcessInstanceApi->SetProcessInstanceVariable");
            // verify the required parameter 'varName' is set
            if (varName == null)
                throw new ApiException(400, "Missing required parameter 'varName' when calling ProcessInstanceApi->SetProcessInstanceVariable");

            var localVarPath = "/process-instance/{id}/variables/{varName}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (varName != null) localVarPathParams.Add("varName", this.Configuration.ApiClient.ParameterToString(varName)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("SetProcessInstanceVariable", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        ///  Sets the serialized value for a binary variable or the binary value for a file variable.
        /// </summary>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to retrieve the variable for.</param>
        /// <param name="varName">The name of the variable to retrieve.</param>
        /// <param name="data"> (optional)</param>
        /// <param name="valueType"> (optional)</param>
        /// <returns></returns>
        public void SetProcessInstanceVariableBinary (string id, string varName, byte[] data = null, string valueType = null)
        {
             SetProcessInstanceVariableBinaryWithHttpInfo(id, varName, data, valueType);
        }

        /// <summary>
        ///  Sets the serialized value for a binary variable or the binary value for a file variable.
        /// </summary>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to retrieve the variable for.</param>
        /// <param name="varName">The name of the variable to retrieve.</param>
        /// <param name="data"> (optional)</param>
        /// <param name="valueType"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> SetProcessInstanceVariableBinaryWithHttpInfo (string id, string varName, byte[] data = null, string valueType = null)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling ProcessInstanceApi->SetProcessInstanceVariableBinary");
            // verify the required parameter 'varName' is set
            if (varName == null)
                throw new ApiException(400, "Missing required parameter 'varName' when calling ProcessInstanceApi->SetProcessInstanceVariableBinary");

            var localVarPath = "/process-instance/{id}/variables/{varName}/data";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "multipart/form-data"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (varName != null) localVarPathParams.Add("varName", this.Configuration.ApiClient.ParameterToString(varName)); // path parameter
            if (data != null) localVarFileParams.Add("data", this.Configuration.ApiClient.ParameterToFile("data", data));
            if (valueType != null) localVarFormParams.Add("valueType", this.Configuration.ApiClient.ParameterToString(valueType)); // form parameter

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("SetProcessInstanceVariableBinary", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        ///  Sets the serialized value for a binary variable or the binary value for a file variable.
        /// </summary>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to retrieve the variable for.</param>
        /// <param name="varName">The name of the variable to retrieve.</param>
        /// <param name="data"> (optional)</param>
        /// <param name="valueType"> (optional)</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task SetProcessInstanceVariableBinaryAsync (string id, string varName, byte[] data = null, string valueType = null)
        {
             await SetProcessInstanceVariableBinaryAsyncWithHttpInfo(id, varName, data, valueType);

        }

        /// <summary>
        ///  Sets the serialized value for a binary variable or the binary value for a file variable.
        /// </summary>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to retrieve the variable for.</param>
        /// <param name="varName">The name of the variable to retrieve.</param>
        /// <param name="data"> (optional)</param>
        /// <param name="valueType"> (optional)</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> SetProcessInstanceVariableBinaryAsyncWithHttpInfo (string id, string varName, byte[] data = null, string valueType = null)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling ProcessInstanceApi->SetProcessInstanceVariableBinary");
            // verify the required parameter 'varName' is set
            if (varName == null)
                throw new ApiException(400, "Missing required parameter 'varName' when calling ProcessInstanceApi->SetProcessInstanceVariableBinary");

            var localVarPath = "/process-instance/{id}/variables/{varName}/data";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "multipart/form-data"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (varName != null) localVarPathParams.Add("varName", this.Configuration.ApiClient.ParameterToString(varName)); // path parameter
            if (data != null) localVarFileParams.Add("data", this.Configuration.ApiClient.ParameterToFile("data", data));
            if (valueType != null) localVarFormParams.Add("valueType", this.Configuration.ApiClient.ParameterToString(valueType)); // form parameter

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("SetProcessInstanceVariableBinary", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        ///  Create a batch to set retries of jobs associated with given processes asynchronously.
        /// </summary>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Please note that if both processInstances and processInstanceQuery are provided,
        /// then the resulting execution will be performed on the union of these sets.
        /// **Unallowed property**: &#x60;historicProcessInstanceQuery&#x60; (optional)</param>
        /// <returns>BatchDto</returns>
        public BatchDto SetRetriesByProcess (SetJobRetriesByProcessDto body = null)
        {
             ApiResponse<BatchDto> localVarResponse = SetRetriesByProcessWithHttpInfo(body);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  Create a batch to set retries of jobs associated with given processes asynchronously.
        /// </summary>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Please note that if both processInstances and processInstanceQuery are provided,
        /// then the resulting execution will be performed on the union of these sets.
        /// **Unallowed property**: &#x60;historicProcessInstanceQuery&#x60; (optional)</param>
        /// <returns>ApiResponse of BatchDto</returns>
        public ApiResponse< BatchDto > SetRetriesByProcessWithHttpInfo (SetJobRetriesByProcessDto body = null)
        {

            var localVarPath = "/process-instance/job-retries";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("SetRetriesByProcess", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<BatchDto>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (BatchDto) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(BatchDto)));
        }

        /// <summary>
        ///  Create a batch to set retries of jobs associated with given processes asynchronously.
        /// </summary>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Please note that if both processInstances and processInstanceQuery are provided,
        /// then the resulting execution will be performed on the union of these sets.
        /// **Unallowed property**: &#x60;historicProcessInstanceQuery&#x60; (optional)</param>
        /// <returns>Task of BatchDto</returns>
        public async System.Threading.Tasks.Task<BatchDto> SetRetriesByProcessAsync (SetJobRetriesByProcessDto body = null)
        {
             ApiResponse<BatchDto> localVarResponse = await SetRetriesByProcessAsyncWithHttpInfo(body);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  Create a batch to set retries of jobs associated with given processes asynchronously.
        /// </summary>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Please note that if both processInstances and processInstanceQuery are provided,
        /// then the resulting execution will be performed on the union of these sets.
        /// **Unallowed property**: &#x60;historicProcessInstanceQuery&#x60; (optional)</param>
        /// <returns>Task of ApiResponse (BatchDto)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<BatchDto>> SetRetriesByProcessAsyncWithHttpInfo (SetJobRetriesByProcessDto body = null)
        {

            var localVarPath = "/process-instance/job-retries";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("SetRetriesByProcess", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<BatchDto>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (BatchDto) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(BatchDto)));
        }

        /// <summary>
        ///  Create a batch to set retries of jobs asynchronously based on a historic process instance query.
        /// </summary>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Please note that if both processInstances and historicProcessInstanceQuery are provided,
        /// then the resulting execution will be performed on the union of these sets.
        /// **Unallowed property**: &#x60;processInstanceQuery&#x60; (optional)</param>
        /// <returns>BatchDto</returns>
        public BatchDto SetRetriesByProcessHistoricQueryBased (SetJobRetriesByProcessDto body = null)
        {
             ApiResponse<BatchDto> localVarResponse = SetRetriesByProcessHistoricQueryBasedWithHttpInfo(body);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  Create a batch to set retries of jobs asynchronously based on a historic process instance query.
        /// </summary>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Please note that if both processInstances and historicProcessInstanceQuery are provided,
        /// then the resulting execution will be performed on the union of these sets.
        /// **Unallowed property**: &#x60;processInstanceQuery&#x60; (optional)</param>
        /// <returns>ApiResponse of BatchDto</returns>
        public ApiResponse< BatchDto > SetRetriesByProcessHistoricQueryBasedWithHttpInfo (SetJobRetriesByProcessDto body = null)
        {

            var localVarPath = "/process-instance/job-retries-historic-query-based";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("SetRetriesByProcessHistoricQueryBased", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<BatchDto>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (BatchDto) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(BatchDto)));
        }

        /// <summary>
        ///  Create a batch to set retries of jobs asynchronously based on a historic process instance query.
        /// </summary>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Please note that if both processInstances and historicProcessInstanceQuery are provided,
        /// then the resulting execution will be performed on the union of these sets.
        /// **Unallowed property**: &#x60;processInstanceQuery&#x60; (optional)</param>
        /// <returns>Task of BatchDto</returns>
        public async System.Threading.Tasks.Task<BatchDto> SetRetriesByProcessHistoricQueryBasedAsync (SetJobRetriesByProcessDto body = null)
        {
             ApiResponse<BatchDto> localVarResponse = await SetRetriesByProcessHistoricQueryBasedAsyncWithHttpInfo(body);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  Create a batch to set retries of jobs asynchronously based on a historic process instance query.
        /// </summary>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Please note that if both processInstances and historicProcessInstanceQuery are provided,
        /// then the resulting execution will be performed on the union of these sets.
        /// **Unallowed property**: &#x60;processInstanceQuery&#x60; (optional)</param>
        /// <returns>Task of ApiResponse (BatchDto)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<BatchDto>> SetRetriesByProcessHistoricQueryBasedAsyncWithHttpInfo (SetJobRetriesByProcessDto body = null)
        {

            var localVarPath = "/process-instance/job-retries-historic-query-based";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("SetRetriesByProcessHistoricQueryBased", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<BatchDto>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (BatchDto) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(BatchDto)));
        }

        /// <summary>
        ///  Activates or suspends process instances by providing certain criteria:  # Activate/Suspend Process Instance By Process Definition Id * &#x60;suspend&#x60; * &#x60;processDefinitionId&#x60;  # Activate/Suspend Process Instance By Process Definition Key  * &#x60;suspend&#x60; * &#x60;processDefinitionKey&#x60; * &#x60;processDefinitionTenantId&#x60; * &#x60;processDefinitionWithoutTenantId&#x60;  # Activate/Suspend Process Instance In Group * &#x60;suspend&#x60; * &#x60;processInstanceIds&#x60; * &#x60;processInstanceQuery&#x60; * &#x60;historicProcessInstanceQuery&#x60;
        /// </summary>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"> (optional)</param>
        /// <returns></returns>
        public void UpdateSuspensionState (ProcessInstanceSuspensionStateDto body = null)
        {
             UpdateSuspensionStateWithHttpInfo(body);
        }

        /// <summary>
        ///  Activates or suspends process instances by providing certain criteria:  # Activate/Suspend Process Instance By Process Definition Id * &#x60;suspend&#x60; * &#x60;processDefinitionId&#x60;  # Activate/Suspend Process Instance By Process Definition Key  * &#x60;suspend&#x60; * &#x60;processDefinitionKey&#x60; * &#x60;processDefinitionTenantId&#x60; * &#x60;processDefinitionWithoutTenantId&#x60;  # Activate/Suspend Process Instance In Group * &#x60;suspend&#x60; * &#x60;processInstanceIds&#x60; * &#x60;processInstanceQuery&#x60; * &#x60;historicProcessInstanceQuery&#x60;
        /// </summary>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateSuspensionStateWithHttpInfo (ProcessInstanceSuspensionStateDto body = null)
        {

            var localVarPath = "/process-instance/suspended";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateSuspensionState", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        ///  Activates or suspends process instances by providing certain criteria:  # Activate/Suspend Process Instance By Process Definition Id * &#x60;suspend&#x60; * &#x60;processDefinitionId&#x60;  # Activate/Suspend Process Instance By Process Definition Key  * &#x60;suspend&#x60; * &#x60;processDefinitionKey&#x60; * &#x60;processDefinitionTenantId&#x60; * &#x60;processDefinitionWithoutTenantId&#x60;  # Activate/Suspend Process Instance In Group * &#x60;suspend&#x60; * &#x60;processInstanceIds&#x60; * &#x60;processInstanceQuery&#x60; * &#x60;historicProcessInstanceQuery&#x60;
        /// </summary>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"> (optional)</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task UpdateSuspensionStateAsync (ProcessInstanceSuspensionStateDto body = null)
        {
             await UpdateSuspensionStateAsyncWithHttpInfo(body);

        }

        /// <summary>
        ///  Activates or suspends process instances by providing certain criteria:  # Activate/Suspend Process Instance By Process Definition Id * &#x60;suspend&#x60; * &#x60;processDefinitionId&#x60;  # Activate/Suspend Process Instance By Process Definition Key  * &#x60;suspend&#x60; * &#x60;processDefinitionKey&#x60; * &#x60;processDefinitionTenantId&#x60; * &#x60;processDefinitionWithoutTenantId&#x60;  # Activate/Suspend Process Instance In Group * &#x60;suspend&#x60; * &#x60;processInstanceIds&#x60; * &#x60;processInstanceQuery&#x60; * &#x60;historicProcessInstanceQuery&#x60;
        /// </summary>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"> (optional)</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> UpdateSuspensionStateAsyncWithHttpInfo (ProcessInstanceSuspensionStateDto body = null)
        {

            var localVarPath = "/process-instance/suspended";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateSuspensionState", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        ///  Activates or suspends process instances asynchronously with a list of process instance ids, a process instance query, and/or a historical process instance query.
        /// </summary>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"> (optional)</param>
        /// <returns>BatchDto</returns>
        public BatchDto UpdateSuspensionStateAsyncOperation (ProcessInstanceSuspensionStateAsyncDto body = null)
        {
             ApiResponse<BatchDto> localVarResponse = UpdateSuspensionStateAsyncOperationWithHttpInfo(body);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  Activates or suspends process instances asynchronously with a list of process instance ids, a process instance query, and/or a historical process instance query.
        /// </summary>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"> (optional)</param>
        /// <returns>ApiResponse of BatchDto</returns>
        public ApiResponse< BatchDto > UpdateSuspensionStateAsyncOperationWithHttpInfo (ProcessInstanceSuspensionStateAsyncDto body = null)
        {

            var localVarPath = "/process-instance/suspended-async";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateSuspensionStateAsyncOperation", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<BatchDto>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (BatchDto) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(BatchDto)));
        }

        /// <summary>
        ///  Activates or suspends process instances asynchronously with a list of process instance ids, a process instance query, and/or a historical process instance query.
        /// </summary>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"> (optional)</param>
        /// <returns>Task of BatchDto</returns>
        public async System.Threading.Tasks.Task<BatchDto> UpdateSuspensionStateAsyncOperationAsync (ProcessInstanceSuspensionStateAsyncDto body = null)
        {
             ApiResponse<BatchDto> localVarResponse = await UpdateSuspensionStateAsyncOperationAsyncWithHttpInfo(body);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  Activates or suspends process instances asynchronously with a list of process instance ids, a process instance query, and/or a historical process instance query.
        /// </summary>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"> (optional)</param>
        /// <returns>Task of ApiResponse (BatchDto)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<BatchDto>> UpdateSuspensionStateAsyncOperationAsyncWithHttpInfo (ProcessInstanceSuspensionStateAsyncDto body = null)
        {

            var localVarPath = "/process-instance/suspended-async";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateSuspensionStateAsyncOperation", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<BatchDto>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (BatchDto) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(BatchDto)));
        }

        /// <summary>
        ///  Activates or suspends a given process instance by id.
        /// </summary>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to activate or suspend.</param>
        /// <param name="body"> (optional)</param>
        /// <returns></returns>
        public void UpdateSuspensionStateById (string id, SuspensionStateDto body = null)
        {
             UpdateSuspensionStateByIdWithHttpInfo(id, body);
        }

        /// <summary>
        ///  Activates or suspends a given process instance by id.
        /// </summary>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to activate or suspend.</param>
        /// <param name="body"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateSuspensionStateByIdWithHttpInfo (string id, SuspensionStateDto body = null)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling ProcessInstanceApi->UpdateSuspensionStateById");

            var localVarPath = "/process-instance/{id}/suspended";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateSuspensionStateById", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        ///  Activates or suspends a given process instance by id.
        /// </summary>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to activate or suspend.</param>
        /// <param name="body"> (optional)</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task UpdateSuspensionStateByIdAsync (string id, SuspensionStateDto body = null)
        {
             await UpdateSuspensionStateByIdAsyncWithHttpInfo(id, body);

        }

        /// <summary>
        ///  Activates or suspends a given process instance by id.
        /// </summary>
        /// <exception cref="Camunda.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to activate or suspend.</param>
        /// <param name="body"> (optional)</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> UpdateSuspensionStateByIdAsyncWithHttpInfo (string id, SuspensionStateDto body = null)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling ProcessInstanceApi->UpdateSuspensionStateById");

            var localVarPath = "/process-instance/{id}/suspended";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateSuspensionStateById", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

    }
}
